initSidebarItems({"enum":[["Concretize",""],["Error","Error types used throughout this crate"],["ReturnValue","A simple enum describing the value returned from a function"],["SolutionValue","A simple enum describing either an integer value or a pointer"]],"fn":[["find_zero_of_func","Given a function, find values of its inputs such that it returns zero. Assumes that the function takes (some number of) integer and/or pointer arguments, and returns an integer. Pointer arguments will be assumed to be never NULL."],["get_possible_return_values_of_func","Get a description of the possible return values of a function, for given argument values. Considers all possible paths through the function given these arguments."],["pretty_bb_name","Format a basic block `Name` into a concise representation for printing"],["symex_function","Begin symbolic execution of the function named `funcname`, obtaining an `ExecutionManager`. The function's parameters will start completely unconstrained."]],"mod":[["alloc_utils","Utility functions for performing memory allocation. These may be useful in implementing hooks for various functions that perform memory allocation."],["backend","Traits which abstract over the backend (BV types, memory implementation, etc) being used."],["function_hooks","Functions and structures for defining and activating function hooks"],["layout","Functions related to the in-memory layout of data types."],["memory","Implementation of a `Memory` based on a Boolector array and 64-bit cells. Handles fully general read and write operations: arbitrary addresses, sizes, and alignments."],["simple_memory","Simple implementation of a `Memory` based on a Boolector array and 8-bit cells. Like the more complicated `Memory` in `memory.rs`, this handles fully general read and write operations: arbitrary addresses, sizes, and alignments."],["solver_utils","Simple utilities for interacting with the solver"],["watchpoints","Structures for defining and processing memory watchpoints"]],"struct":[["Config","Various settings which affect how the symbolic execution is performed."],["ExecutionManager","An `ExecutionManager` allows you to symbolically explore executions of a function. Conceptually, it is an `Iterator` over possible paths through the function. Calling `next()` on an `ExecutionManager` explores another possible path, returning a `ReturnValue` representing the function's symbolic return value at the end of that path."],["Location","Fully describes a code location within the LLVM IR."],["PathEntry","Describes one segment of a path through the LLVM IR."],["Project","A `Project` is a collection of LLVM code to be explored, consisting of one or more LLVM modules"],["State","A `State` describes the full program state at a given moment during symbolic execution."]],"type":[["Result","A type alias for convenience, similar to how `std::io::Result` is used for I/O operations"]]});