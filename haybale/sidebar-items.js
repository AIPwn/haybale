initSidebarItems({"enum":[["Concretize",""],["Error",""],["ReturnValue",""],["SolutionValue",""]],"fn":[["find_zero_of_func","Given a function, find values of its inputs such that it returns zero. Assumes function takes (some number of) integer and/or pointer arguments, and returns an integer. Pointer arguments will be assumed to be never NULL."],["get_possible_return_values_of_func","Get a description of the possible return values of a function, for given argument values. Considers all possible paths through the function given these arguments."],["pretty_bb_name",""],["symex_function","Begin symbolic execution of the function named `funcname`, obtaining an `ExecutionManager`. The function's parameters will start completely unconstrained."]],"mod":[["alloc_utils","Utility functions for performing memory allocation. These may be useful in implementing hooks for various functions that perform memory allocation."],["backend","Traits which abstract over the backend (BV types, memory implementation, SMT solver) being used."],["layout","Functions related to the in-memory layout of data types."],["memory","Implementation of a `Memory` based on a Boolector array and 64-bit cells. Handles fully general read and write operations: arbitrary addresses, sizes, and alignments."],["simple_memory","Simple implementation of a `Memory` based on a Boolector array and 8-bit cells. Like the more complicated `Memory` in `memory.rs`, this handles fully general read and write operations: arbitrary addresses, sizes, and alignments."],["solver_utils","Simple utilities for interacting with the solver"]],"struct":[["Config",""],["ExecutionManager","An `ExecutionManager` allows you to symbolically explore executions of a function. Conceptually, it is an `Iterator` over possible paths through the function. Calling `next()` on an `ExecutionManager` explores another possible path, returning a `ReturnValue` representing the function's symbolic return value at the end of that path."],["FunctionHooks",""],["Location",""],["PathEntry",""],["Project","A `Project` is a collection of LLVM code to be explored, consisting of one or more LLVM modules"],["State",""]],"type":[["Result","A type alias for convenience, similar to how `std::io::Result` is used for I/O operations"]]});