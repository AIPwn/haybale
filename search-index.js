var N=null,E="",T="t",U="u",searchIndex={};
var R=["bbname","config","backend","btorbackend","project","string","result","Construct a new `Project` from a path to a directory…","error","option","Get the offset (in bytes) of the element at the given…","operand","haybale","Returns `true` if under the current constraints, `a` and…","bvsolution","possiblesolutions","location","A new `Memory`, whose contents at all addresses are…","INDEX_BITS","CELL_BITS","BITS_IN_BYTE","LOG_BITS_IN_BYTE","CELL_BYTES","new_uninitialized","new_zero_initialized","get_solver","Get a reference to the `Btor` instance this `Memory`…","change_solver","Adapt the `Memory` to a new `Btor` instance.","Read any number (>0) of bits of memory, at any alignment.…","Write any number (>0) of bits of memory, at any alignment.","Returns `true` if current constraints are satisfiable,…","sat_with_extra_constraints","bvs_must_be_equal","bvs_can_be_equal","get_possible_solutions_for_bv","Get a description of the possible solutions for the `BV`.","max_possible_solution_for_bv","Get the maximum possible solution for the `BV`: that is,…","min_possible_solution_for_bv","Get the minimum possible solution for the `BV`: that is,…","SolverRef","try_from","try_into","borrow_mut","to_owned","clone_into","type_id","borrow","typeid","haybale::memory","haybale::simple_memory","haybale::solver_utils","haybale::backend","pathentry","ordering","concretize","solutioncount","solutionvalue","memory","returnvalue","simplememorybackend","formatter","Location","PathEntry","Concretize","ReturnValue","SolutionValue","ExecutionManager","FunctionHooks","Memory","PossibleSolutions","SolutionCount","BtorBackend","SimpleMemoryBackend"];

searchIndex["haybale"]={"doc":"For an introduction to the crate and how to get started,…","i":[[3,"Project",R[12],"A `Project` is a collection of LLVM code to be explored,…",N,N],[3,"State",E,"A `State` describes the full program state at a given…",N,N],[12,"solver",E,"Reference to the solver instance being used",0,N],[12,R[1],E,"The configuration being used",0,N],[12,"cur_loc",E,"Indicates the instruction which is currently being executed",0,N],[3,R[63],E,"Fully describes a code location within the LLVM IR.",N,N],[12,"module",E,E,1,N],[12,"func",E,E,1,N],[12,R[0],E,E,1,N],[12,"instr",E,"Index of the instruction within the basic block. E.g., 0…",1,N],[3,R[64],E,"Describes one segment of a path through the LLVM IR.",N,N],[12,"modname",E,E,2,N],[12,"funcname",E,E,2,N],[12,R[0],E,E,2,N],[12,"instr",E,"Index of the instruction within the basic block at which…",2,N],[3,R[68],E,"An `ExecutionManager` allows you to symbolically explore…",N,N],[3,"Config",E,"Various settings which affect how the symbolic execution…",N,N],[12,"loop_bound",E,"Maximum number of times to execute any given line of LLVM…",3,N],[12,"null_detection",E,"If `true`, all memory accesses will be checked to ensure…",3,N],[12,"concretize_memcpy_lengths",E,"When encountering a `memcpy`, `memset`, or `memmove` with…",3,N],[12,"function_hooks",E,"The set of currently active function hooks; see…",3,N],[3,R[69],E,"A set of function hooks, which will be executed instead of…",N,N],[4,R[65],E,E,N,N],[13,"Symbolic",E,"Handle everything fully symbolically - that is, have the…",4,N],[13,"Arbitrary",E,"Pick one possible value arbitrarily. Often this may choose…",4,N],[13,"Prefer",E,"Prefer the given `u64` value if it is a possible value.…",4,N],[13,"Maximum",E,"Choose the maximum possible value. `Maximum` will be…",4,N],[13,"Minimum",E,"Choose the minimum possible value. `Minimum` will be…",4,N],[4,R[66],E,"A simple enum describing the value returned from a function",N,N],[13,"Return",E,"The function or call returns this value",5,N],[13,"ReturnVoid",E,"The function or call returns void",5,N],[4,"Error",E,"Error types used throughout this crate",N,N],[13,"Unsat",E,"While performing an operation, we discovered the current…",6,N],[13,"LoopBoundExceeded",E,"The current path has exceeded the configured `loop_bound`…",6,N],[13,"NullPointerDereference",E,"The current path has attempted to dereference a null…",6,N],[13,"FunctionNotFound",E,"Processing a call of a function with the given name, but…",6,N],[13,"BoolCoercionError",E,"An operation attempted to coerce a `BV` more than one bit…",6,N],[13,"SolverError",E,"The solver returned this processing error while evaluating…",6,N],[13,"UnsupportedInstruction",E,"Encountered an LLVM instruction which is not currently…",6,N],[13,"MalformedInstruction",E,"Encountered an LLVM instruction which was malformed, or at…",6,N],[13,"OtherError",E,"Some kind of error which doesn't fall into one of the…",6,N],[4,R[67],E,"A simple enum describing either an integer value or a…",N,N],[13,"I8",E,E,7,N],[13,"I16",E,E,7,N],[13,"I32",E,E,7,N],[13,"I64",E,E,7,N],[13,"Ptr",E,E,7,N],[5,"pretty_bb_name",E,"Format a basic block `Name` into a concise representation…",N,[[["name"]],[R[5]]]],[5,"symex_function",E,"Begin symbolic execution of the function named `funcname`,…",N,[[[R[2]],[R[1]],["str"],[R[4]]],[["executionmanager"],[R[2]]]]],[5,"find_zero_of_func",E,"Given a function, find values of its inputs such that it…",N,[[[R[1],[R[3]]],[R[3]],["str"],[R[4]]],[[R[9],["vec"]],["vec",[R[58]]]]]],[5,"get_possible_return_values_of_func",E,"Get a description of the possible return values of a…",N,[[[R[1],[R[3]]],[R[3]],["usize"],["str"],[R[4]]],[[R[15],["u64"]],["u64"]]]],[11,"from_bc_path",E,"Construct a new `Project` from a path to an LLVM bitcode…",8,[[],[[R[5]],[R[6],[R[5]]]]]],[11,"from_bc_paths",E,"Construct a new `Project` from multiple LLVM bitcode files",8,[[],[[R[5]],[R[6],[R[5]]]]]],[11,"from_bc_dir",E,R[7],8,[[["str"]],[[R[6],[R[8]]],[R[8]]]]],[11,"from_bc_dir_with_blacklist",E,R[7],8,[[["str"]],[[R[6],[R[8]]],[R[8]]]]],[11,"add_bc_path",E,"Add the code in the given LLVM bitcode file to the `Project`",8,[[["self"]],[[R[5]],[R[6],[R[5]]]]]],[11,"add_bc_dir",E,"Add the code in the given directory to the `Project`. See…",8,[[["self"],["str"]],[[R[6],[R[8]]],[R[8]]]]],[11,"add_bc_dir_with_blacklist",E,"Add the code in the given directory, except for…",8,[[["self"],["str"]],[[R[6],[R[8]]],[R[8]]]]],[11,"all_functions",E,"Iterate over all `Function`s in the `Project`. Gives pairs…",8,[[["self"]]]],[11,"all_global_vars",E,"Iterate over all `GlobalVariable`s in the `Project`. Gives…",8,[[["self"]]]],[11,"all_global_aliases",E,"Iterate over all `GlobalAlias`es in the `Project`. Gives…",8,[[["self"]]]],[11,"all_named_struct_types",E,"Iterate over all named struct types in the `Project`.…",8,[[["self"]]]],[11,"active_module_names",E,"Get the names of the LLVM modules which have been parsed…",8,[[["self"]]]],[11,"get_func_by_name",E,"Search the project for a function with the given name. If…",8,[[["str"],["self"]],[R[9]]]],[11,"get_named_struct_type_by_name",E,"Search the project for a named struct type with the given…",8,[[["str"],["self"]],[R[9]]]],[11,"state",E,"Provides access to the `State` resulting from the end of…",9,[[["self"]],["state"]]],[11,"mut_state",E,"Provides mutable access to the underlying `State` (see…",9,[[["self"]],["state"]]],[11,"param_bvs",E,"Provides access to the `BV` objects representing each of…",9,[[["self"]],["vec"]]],[0,"layout",E,"Functions related to the in-memory layout of data types.",N,N],[5,"size","haybale::layout","Get the size of the `Type`, in bits",N,[[["type"]],["usize"]]],[5,"fp_size",E,"Get the size of the `FPType`, in bits",N,[[["fptype"]],["usize"]]],[5,"get_offset_constant_index",E,R[10],N,[[["type"],["usize"]],[R[6]]]],[5,"get_offset_bv_index",E,R[10],N,[[["type"],["v"]],[R[6]]]],[11,"new",R[12],"Creates a new `Config` with the given `loop_bound` and…",3,[[[R[56]],["usize"],["bool"]],["self"]]],[11,"new",E,"Create a blank `FunctionHooks` instance with no function…",10,[[],["self"]]],[11,"add",E,"Adds a function hook. The `hook` will be executed instead…",10,[[["self"],["h"]]]],[11,"remove",E,"Removes the function hook for the given function. That…",10,[[["self"],["str"]]]],[11,"is_hooked",E,"Determine whether there is an active hook for the given…",10,[[["self"],["str"]],["bool"]]],[0,"alloc_utils",E,"Utility functions for performing memory allocation. These…",N,N],[5,"malloc","haybale::alloc_utils","Allocate a number of bytes given by the `Operand`.",N,[[["state"],[R[11]]],[R[6]]]],[5,"zalloc",E,"Allocate a number of bytes given by the `Operand`. The…",N,[[["state"],[R[11]]],[R[6]]]],[5,"calloc",E,"Allocate a number of bytes given by `a` times `b`, where…",N,[[["state"],[R[11]]],[R[6]]]],[5,"realloc",E,"Reallocate the given `addr` to be at least the number of…",N,[[["state"],[R[11]]],[R[6]]]],[11,"new",R[12],"`start_loc`: the `Location` where the `State` should begin…",0,[[[R[1]],[R[4]],[R[16]]],["self"]]],[11,"fork",E,"Fully duplicate the `State`. Unlike with `clone()`, the…",0,[[["self"]],["self"]]],[11,"sat",E,R[31],0,[[["self"]],[["bool"],[R[6],["bool"]]]]],[11,R[32],E,"Returns `true` if the current constraints plus the given…",0,[[["self"]],[["bool"],[R[6],["bool"]]]]],[11,R[33],E,R[13],0,[[["self"]],[["bool"],[R[6],["bool"]]]]],[11,R[34],E,R[13],0,[[["self"]],[["bool"],[R[6],["bool"]]]]],[11,"get_a_solution_for_bv",E,"Get one possible concrete value for the `BV`. Returns…",0,[[["self"]],[[R[9],[R[14]]],[R[6],[R[9]]]]]],[11,"get_a_solution_for_irname",E,"Get one possible concrete value for the given IR `Name`…",0,[[["self"],["name"],[R[5]]],[[R[9],[R[14]]],[R[6],[R[9]]]]]],[11,R[35],E,R[36],0,[[["self"],["usize"]],[[R[6],[R[15]]],[R[15],[R[14]]]]]],[11,"get_possible_solutions_for_irname",E,"Get a description of the possible solutions for the given…",0,[[["self"],["name"],[R[5]],["usize"]],[[R[6],[R[15]]],[R[15],[R[14]]]]]],[11,R[37],E,R[38],0,[[["self"]],[[R[6],[R[9]]],[R[9],["u64"]]]]],[11,"max_possible_solution_for_irname",E,"Get the maximum possible solution for the given IR `Name`…",0,[[["self"],["name"],[R[5]]],[[R[6],[R[9]]],[R[9],["u64"]]]]],[11,R[39],E,R[40],0,[[["self"]],[[R[6],[R[9]]],[R[9],["u64"]]]]],[11,"min_possible_solution_for_irname",E,"Get the minimum possible solution for the given IR `Name`…",0,[[["self"],["name"],[R[5]]],[[R[6],[R[9]]],[R[9],["u64"]]]]],[11,"new_bv_with_name",E,"Create a new (unconstrained) `BV` for the given `Name` (in…",0,[[["self"],["u32"],["name"]],[R[6]]]],[11,"assign_bv_to_name",E,"Assign the given `BV` to the given `Name` (in the current…",0,[[["self"],["name"]],[R[6]]]],[11,"record_bv_result",E,"Record the result of `thing` to be `resultval`. Assumes…",0,[[["self"]],[R[6]]]],[11,"overwrite_latest_version_of_bv",E,"Overwrite the latest version of the given `Name` to…",0,[[["self"],["name"]]]],[11,"operand_to_bv",E,"Convert an `Operand` to the appropriate `BV`. Assumes the…",0,[[["self"],[R[11]]],[R[6]]]],[11,"const_to_bv",E,"Convert a `Constant` to the appropriate `BV`.",0,[[["self"],["constant"]],[R[6]]]],[11,"get_pointer_to_function",E,"Get a pointer to the given function name. The name will be…",0,[[["self"]],[R[9]]]],[11,"get_pointer_to_function_hook",E,"Get a pointer to the currently active hook for the given…",0,[[["self"],["str"]],[R[9]]]],[11,"read",E,"Read a value `bits` bits long from memory at `addr`. Note…",0,[[["self"],["u32"]],[R[6]]]],[11,"write",E,"Write a value into memory at `addr`. Note that `val` can…",0,[[["self"]],[R[6]]]],[11,"allocate",E,"Allocate a value of size `bits`; return a pointer to the…",0,[[["self"]]]],[11,"get_allocation_size",E,"Get the size, in bits, of the allocation at the given…",0,[[["self"]],[[R[6],[R[9]]],[R[9],["u64"]]]]],[11,"record_path_entry",E,"Record the current location as a `PathEntry` in the…",0,[[["self"]]]],[11,"get_path",E,"Get the `PathEntry`s that have been recorded, in order",0,[[["self"]],["vec"]]],[11,"push_callsite",E,"Record entering a call at the current location",0,[[["self"]]]],[11,"pop_callsite",E,"Record leaving the current function. Returns the…",0,[[["self"]],[[R[9],[R[16]]],[R[16]]]]],[11,"save_backtracking_point",E,"Save the current state, about to enter the `BasicBlock`…",0,[[["self"],["name"]]]],[11,"revert_to_backtracking_point",E,"returns `Ok(true)` if the operation was successful,…",0,[[["self"]],[["bool"],[R[6],["bool"]]]]],[11,"count_backtracking_points",E,"returns the number of saved backtracking points",0,[[["self"]],["usize"]]],[11,"pretty_llvm_backtrace",E,"returns a `String` containing a formatted view of the…",0,[[["self"]],[R[5]]]],[11,"current_assignments_as_pretty_string",E,"returns a `String` describing a set of satisfying…",0,[[["self"]],[[R[5]],[R[6],[R[5]]]]]],[0,R[59],E,"Implementation of a `Memory` based on a Boolector array…",N,N],[3,R[70],R[50],E,N,N],[18,R[18],E,E,11,N],[18,R[19],E,E,11,N],[18,R[20],E,E,11,N],[18,R[21],E,E,11,N],[18,R[22],E,E,11,N],[18,"LOG_CELL_BYTES",E,E,11,N],[18,"CELL_OFFSET_MASK",E,E,11,N],[11,R[23],E,R[17],11,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,R[24],E,R[17],11,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,R[25],E,R[26],11,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[27],E,R[28],11,[[["self"],["rc",["btor"]],["btor"]]]],[11,"read",E,R[29],11,[[["self"],["u32"],["bv"]],[[R[6],["bv"]],["bv",["rc"]]]]],[11,"write",E,R[30],11,[[["self"],["bv"],["rc",["btor"]],["bv",["rc"]]],[R[6]]]],[0,"simple_memory",R[12],"Simple implementation of a `Memory` based on a Boolector…",N,N],[3,R[70],R[51],E,N,N],[18,R[18],E,E,12,N],[18,R[19],E,E,12,N],[18,R[20],E,E,12,N],[18,R[21],E,E,12,N],[18,R[22],E,E,12,N],[11,R[23],E,R[17],12,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,R[24],E,R[17],12,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,R[25],E,R[26],12,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[27],E,R[28],12,[[["self"],["rc",["btor"]],["btor"]]]],[11,"read",E,R[29],12,[[["self"],["u32"],["bv"]],[[R[6],["bv"]],["bv",["rc"]]]]],[11,"write",E,R[30],12,[[["self"],["bv"],["rc",["btor"]],["bv",["rc"]]],[R[6]]]],[0,"solver_utils",R[12],"Simple utilities for interacting with the solver",N,N],[4,R[71],R[52],E,N,N],[13,"Exactly",E,"This is exactly the set of possible solutions; there are…",13,N],[13,"AtLeast",E,"All of the solutions in this set are possible solutions,…",13,N],[4,R[72],E,E,N,N],[13,"Exactly",E,"There are exactly this many solutions",14,N],[13,"AtLeast",E,"There are at least this many solutions",14,N],[5,"sat",E,R[31],N,[[["btor"]],[["bool"],[R[6],["bool"]]]]],[5,R[32],E,"Returns `true` if the current constraints plus the…",N,[[["btor"]],[["bool"],[R[6],["bool"]]]]],[5,R[33],E,R[13],N,[[["btor"],["v"]],[["bool"],[R[6],["bool"]]]]],[5,R[34],E,R[13],N,[[["btor"],["v"]],[["bool"],[R[6],["bool"]]]]],[5,R[35],E,R[36],N,[[["usize"],["v"]],[[R[6],[R[15]]],[R[15],[R[14]]]]]],[5,R[37],E,R[38],N,[[["v"]],[[R[6],[R[9]]],[R[9],["u64"]]]]],[5,R[39],E,R[40],N,[[["v"]],[[R[6],[R[9]]],[R[9],["u64"]]]]],[11,"as_u64_solutions",E,"Convert a `PossibleSolutions` over `BVSolution` into a…",13,[[["self"]],[[R[15],["u64"]],[R[9],[R[15]]]]]],[11,"count",E,"Get a count of how many possible solutions there are.",13,[[["self"]],[R[57]]]],[0,R[2],R[12],"Traits which abstract over the backend (BV types, memory…",N,N],[3,R[73],R[53],E,N,N],[3,R[74],E,E,N,N],[8,"Backend",E,"A `Backend` is just a collection of types which together…",N,N],[16,R[41],E,E,15,N],[16,"BV",E,E,15,N],[16,R[70],E,E,15,N],[8,R[41],E,"Trait for something which acts as a reference to a…",N,N],[16,"BV",E,E,16,N],[16,"Array",E,E,16,N],[10,"new",E,"Create a new `Btor` instance, initialize it as necessary,…",16,[[],["self"]]],[10,"duplicate",E,"As opposed to `clone()` which merely clones the reference,…",16,[[["self"]],["self"]]],[10,"match_bv",E,"Given a `BV` originally created for any `SolverRef`, get…",16,[[["self"]],[R[9]]]],[10,"match_array",E,"Given an `Array` originally created for any `SolverRef`,…",16,[[["self"]],[R[9]]]],[8,"BV",E,"Trait for things which can act like bitvectors",N,N],[16,R[41],E,E,17,N],[10,"new",E,E,17,[[["u32"],[R[9],["str"]],["str"]],["self"]]],[10,"from_bool",E,E,17,[[["bool"]],["self"]]],[10,"from_i32",E,E,17,[[["u32"],["i32"]],["self"]]],[10,"from_u32",E,E,17,[[["u32"]],["self"]]],[10,"from_i64",E,E,17,[[["i64"],["u32"]],["self"]]],[10,"from_u64",E,E,17,[[["u32"],["u64"]],["self"]]],[10,"zero",E,E,17,[[["u32"]],["self"]]],[10,"one",E,E,17,[[["u32"]],["self"]]],[10,"ones",E,E,17,[[["u32"]],["self"]]],[10,"from_binary_str",E,E,17,[[["str"]],["self"]]],[10,"from_dec_str",E,E,17,[[["u32"],["str"]],["self"]]],[10,"from_hex_str",E,E,17,[[["u32"],["str"]],["self"]]],[10,"as_binary_str",E,E,17,[[["self"]],[[R[9],[R[5]]],[R[5]]]]],[10,"as_u64",E,E,17,[[["self"]],[[R[9],["u64"]],["u64"]]]],[10,"as_bool",E,E,17,[[["self"]],[[R[9],["bool"]],["bool"]]]],[10,"get_a_solution",E,E,17,[[["self"]],[[R[6],[R[14]]],[R[14]]]]],[10,"get_id",E,E,17,[[["self"]],["i32"]]],[10,"get_width",E,E,17,[[["self"]],["u32"]]],[10,"get_symbol",E,E,17,[[["self"]],[[R[9],["str"]],["str"]]]],[10,"set_symbol",E,E,17,[[["self"],[R[9],["str"]],["str"]]]],[10,"is_const",E,E,17,[[["self"]],["bool"]]],[10,"has_same_width",E,E,17,[[["self"]],["bool"]]],[10,"assert",E,E,17,[[["self"]],[R[6]]]],[10,"is_failed_assumption",E,E,17,[[["self"]],["bool"]]],[10,"_eq",E,E,17,[[["self"]],["self"]]],[10,"_ne",E,E,17,[[["self"]],["self"]]],[10,"add",E,E,17,[[["self"]],["self"]]],[10,"sub",E,E,17,[[["self"]],["self"]]],[10,"mul",E,E,17,[[["self"]],["self"]]],[10,"udiv",E,E,17,[[["self"]],["self"]]],[10,"sdiv",E,E,17,[[["self"]],["self"]]],[10,"urem",E,E,17,[[["self"]],["self"]]],[10,"srem",E,E,17,[[["self"]],["self"]]],[10,"smod",E,E,17,[[["self"]],["self"]]],[10,"inc",E,E,17,[[["self"]],["self"]]],[10,"dec",E,E,17,[[["self"]],["self"]]],[10,"neg",E,E,17,[[["self"]],["self"]]],[10,"uaddo",E,E,17,[[["self"]],["self"]]],[10,"saddo",E,E,17,[[["self"]],["self"]]],[10,"usubo",E,E,17,[[["self"]],["self"]]],[10,"ssubo",E,E,17,[[["self"]],["self"]]],[10,"umulo",E,E,17,[[["self"]],["self"]]],[10,"smulo",E,E,17,[[["self"]],["self"]]],[10,"sdivo",E,E,17,[[["self"]],["self"]]],[10,"not",E,E,17,[[["self"]],["self"]]],[10,"and",E,E,17,[[["self"]],["self"]]],[10,"or",E,E,17,[[["self"]],["self"]]],[10,"xor",E,E,17,[[["self"]],["self"]]],[10,"nand",E,E,17,[[["self"]],["self"]]],[10,"nor",E,E,17,[[["self"]],["self"]]],[10,"xnor",E,E,17,[[["self"]],["self"]]],[10,"sll",E,E,17,[[["self"]],["self"]]],[10,"srl",E,E,17,[[["self"]],["self"]]],[10,"sra",E,E,17,[[["self"]],["self"]]],[10,"rol",E,E,17,[[["self"]],["self"]]],[10,"ror",E,E,17,[[["self"]],["self"]]],[10,"redand",E,E,17,[[["self"]],["self"]]],[10,"redor",E,E,17,[[["self"]],["self"]]],[10,"redxor",E,E,17,[[["self"]],["self"]]],[10,"ugt",E,E,17,[[["self"]],["self"]]],[10,"ugte",E,E,17,[[["self"]],["self"]]],[10,"sgt",E,E,17,[[["self"]],["self"]]],[10,"sgte",E,E,17,[[["self"]],["self"]]],[10,"ult",E,E,17,[[["self"]],["self"]]],[10,"ulte",E,E,17,[[["self"]],["self"]]],[10,"slt",E,E,17,[[["self"]],["self"]]],[10,"slte",E,E,17,[[["self"]],["self"]]],[10,"zext",E,E,17,[[["self"],["u32"]],["self"]]],[10,"sext",E,E,17,[[["self"],["u32"]],["self"]]],[10,"slice",E,E,17,[[["self"],["u32"]],["self"]]],[10,"concat",E,E,17,[[["self"]],["self"]]],[10,"repeat",E,E,17,[[["self"],["u32"]],["self"]]],[10,"iff",E,E,17,[[["self"]],["self"]]],[10,"implies",E,E,17,[[["self"]],["self"]]],[10,"cond_bv",E,E,17,[[["self"]],["self"]]],[8,R[70],E,"Trait for things which can act like 'memories', that is,…",N,N],[16,R[41],E,E,18,N],[16,"Index",E,E,18,N],[16,"Value",E,E,18,N],[10,R[23],E,R[17],18,[[[R[9],["str"]],["str"],["bool"]],["self"]]],[10,R[24],E,R[17],18,[[[R[9],["str"]],["str"],["bool"]],["self"]]],[10,"read",E,R[29],18,[[["self"],["u32"]],[R[6]]]],[10,"write",E,R[30],18,[[["self"]],[R[6]]]],[10,R[25],E,"Get a reference to the solver instance this `Memory`…",18,[[["self"]]]],[10,R[27],E,"Adapt the `Memory` to a new solver instance.",18,[[["self"]]]],[6,"Result",R[12],"A type alias for convenience, similar to how…",N,N],[11,"unwrap_to_i8",E,E,7,[[],["i8"]]],[11,"unwrap_to_i16",E,E,7,[[],["i16"]]],[11,"unwrap_to_i32",E,E,7,[[],["i32"]]],[11,"unwrap_to_i64",E,E,7,[[],["i64"]]],[11,"unwrap_to_ptr",E,E,7,[[],["u64"]]],[11,"from",E,E,8,[[[T]],[T]]],[11,"into",E,E,8,[[],[U]]],[11,R[42],E,E,8,[[[U]],[R[6]]]],[11,R[43],E,E,8,[[],[R[6]]]],[11,R[48],E,E,8,[[["self"]],[T]]],[11,R[44],E,E,8,[[["self"]],[T]]],[11,R[47],E,E,8,[[["self"]],[R[49]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[45],E,E,0,[[["self"]],[T]]],[11,R[46],E,E,0,[[["self"],[T]]]],[11,"into",E,E,0,[[],[U]]],[11,R[42],E,E,0,[[[U]],[R[6]]]],[11,R[43],E,E,0,[[],[R[6]]]],[11,R[48],E,E,0,[[["self"]],[T]]],[11,R[44],E,E,0,[[["self"]],[T]]],[11,R[47],E,E,0,[[["self"]],[R[49]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[45],E,E,1,[[["self"]],[T]]],[11,R[46],E,E,1,[[["self"],[T]]]],[11,"into",E,E,1,[[],[U]]],[11,R[42],E,E,1,[[[U]],[R[6]]]],[11,R[43],E,E,1,[[],[R[6]]]],[11,R[48],E,E,1,[[["self"]],[T]]],[11,R[44],E,E,1,[[["self"]],[T]]],[11,R[47],E,E,1,[[["self"]],[R[49]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[45],E,E,2,[[["self"]],[T]]],[11,R[46],E,E,2,[[["self"],[T]]]],[11,"into",E,E,2,[[],[U]]],[11,R[42],E,E,2,[[[U]],[R[6]]]],[11,R[43],E,E,2,[[],[R[6]]]],[11,R[48],E,E,2,[[["self"]],[T]]],[11,R[44],E,E,2,[[["self"]],[T]]],[11,R[47],E,E,2,[[["self"]],[R[49]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into_iter",E,E,9,[[],["i"]]],[11,"into",E,E,9,[[],[U]]],[11,R[42],E,E,9,[[[U]],[R[6]]]],[11,R[43],E,E,9,[[],[R[6]]]],[11,R[48],E,E,9,[[["self"]],[T]]],[11,R[44],E,E,9,[[["self"]],[T]]],[11,R[47],E,E,9,[[["self"]],[R[49]]]],[11,"reduce",E,E,9,[[["f"]],[R[9]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[45],E,E,3,[[["self"]],[T]]],[11,R[46],E,E,3,[[["self"],[T]]]],[11,"into",E,E,3,[[],[U]]],[11,R[42],E,E,3,[[[U]],[R[6]]]],[11,R[43],E,E,3,[[],[R[6]]]],[11,R[48],E,E,3,[[["self"]],[T]]],[11,R[44],E,E,3,[[["self"]],[T]]],[11,R[47],E,E,3,[[["self"]],[R[49]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,R[45],E,E,10,[[["self"]],[T]]],[11,R[46],E,E,10,[[["self"],[T]]]],[11,"into",E,E,10,[[],[U]]],[11,R[42],E,E,10,[[[U]],[R[6]]]],[11,R[43],E,E,10,[[],[R[6]]]],[11,R[48],E,E,10,[[["self"]],[T]]],[11,R[44],E,E,10,[[["self"]],[T]]],[11,R[47],E,E,10,[[["self"]],[R[49]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[45],E,E,4,[[["self"]],[T]]],[11,R[46],E,E,4,[[["self"],[T]]]],[11,"into",E,E,4,[[],[U]]],[11,R[42],E,E,4,[[[U]],[R[6]]]],[11,R[43],E,E,4,[[],[R[6]]]],[11,R[48],E,E,4,[[["self"]],[T]]],[11,R[44],E,E,4,[[["self"]],[T]]],[11,R[47],E,E,4,[[["self"]],[R[49]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[45],E,E,5,[[["self"]],[T]]],[11,R[46],E,E,5,[[["self"],[T]]]],[11,"into",E,E,5,[[],[U]]],[11,R[42],E,E,5,[[[U]],[R[6]]]],[11,R[43],E,E,5,[[],[R[6]]]],[11,R[48],E,E,5,[[["self"]],[T]]],[11,R[44],E,E,5,[[["self"]],[T]]],[11,R[47],E,E,5,[[["self"]],[R[49]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,"to_string",E,E,6,[[["self"]],[R[5]]]],[11,R[45],E,E,6,[[["self"]],[T]]],[11,R[46],E,E,6,[[["self"],[T]]]],[11,"into",E,E,6,[[],[U]]],[11,R[42],E,E,6,[[[U]],[R[6]]]],[11,R[43],E,E,6,[[],[R[6]]]],[11,R[48],E,E,6,[[["self"]],[T]]],[11,R[44],E,E,6,[[["self"]],[T]]],[11,R[47],E,E,6,[[["self"]],[R[49]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[45],E,E,7,[[["self"]],[T]]],[11,R[46],E,E,7,[[["self"],[T]]]],[11,"into",E,E,7,[[],[U]]],[11,R[42],E,E,7,[[[U]],[R[6]]]],[11,R[43],E,E,7,[[],[R[6]]]],[11,R[48],E,E,7,[[["self"]],[T]]],[11,R[44],E,E,7,[[["self"]],[T]]],[11,R[47],E,E,7,[[["self"]],[R[49]]]],[11,"from",R[50],E,11,[[[T]],[T]]],[11,R[45],E,E,11,[[["self"]],[T]]],[11,R[46],E,E,11,[[["self"],[T]]]],[11,"into",E,E,11,[[],[U]]],[11,R[42],E,E,11,[[[U]],[R[6]]]],[11,R[43],E,E,11,[[],[R[6]]]],[11,R[48],E,E,11,[[["self"]],[T]]],[11,R[44],E,E,11,[[["self"]],[T]]],[11,R[47],E,E,11,[[["self"]],[R[49]]]],[11,"from",R[51],E,12,[[[T]],[T]]],[11,R[45],E,E,12,[[["self"]],[T]]],[11,R[46],E,E,12,[[["self"],[T]]]],[11,"into",E,E,12,[[],[U]]],[11,R[42],E,E,12,[[[U]],[R[6]]]],[11,R[43],E,E,12,[[],[R[6]]]],[11,R[48],E,E,12,[[["self"]],[T]]],[11,R[44],E,E,12,[[["self"]],[T]]],[11,R[47],E,E,12,[[["self"]],[R[49]]]],[11,"from",R[52],E,13,[[[T]],[T]]],[11,R[45],E,E,13,[[["self"]],[T]]],[11,R[46],E,E,13,[[["self"],[T]]]],[11,"into",E,E,13,[[],[U]]],[11,R[42],E,E,13,[[[U]],[R[6]]]],[11,R[43],E,E,13,[[],[R[6]]]],[11,R[48],E,E,13,[[["self"]],[T]]],[11,R[44],E,E,13,[[["self"]],[T]]],[11,R[47],E,E,13,[[["self"]],[R[49]]]],[11,"from",E,E,14,[[[T]],[T]]],[11,R[45],E,E,14,[[["self"]],[T]]],[11,R[46],E,E,14,[[["self"],[T]]]],[11,"into",E,E,14,[[],[U]]],[11,R[42],E,E,14,[[[U]],[R[6]]]],[11,R[43],E,E,14,[[],[R[6]]]],[11,R[48],E,E,14,[[["self"]],[T]]],[11,R[44],E,E,14,[[["self"]],[T]]],[11,R[47],E,E,14,[[["self"]],[R[49]]]],[11,"from",R[53],E,19,[[[T]],[T]]],[11,R[45],E,E,19,[[["self"]],[T]]],[11,R[46],E,E,19,[[["self"],[T]]]],[11,"into",E,E,19,[[],[U]]],[11,R[42],E,E,19,[[[U]],[R[6]]]],[11,R[43],E,E,19,[[],[R[6]]]],[11,R[48],E,E,19,[[["self"]],[T]]],[11,R[44],E,E,19,[[["self"]],[T]]],[11,R[47],E,E,19,[[["self"]],[R[49]]]],[11,"from",E,E,20,[[[T]],[T]]],[11,R[45],E,E,20,[[["self"]],[T]]],[11,R[46],E,E,20,[[["self"],[T]]]],[11,"into",E,E,20,[[],[U]]],[11,R[42],E,E,20,[[[U]],[R[6]]]],[11,R[43],E,E,20,[[],[R[6]]]],[11,R[48],E,E,20,[[["self"]],[T]]],[11,R[44],E,E,20,[[["self"]],[T]]],[11,R[47],E,E,20,[[["self"]],[R[49]]]],[11,R[23],R[50],E,11,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,R[24],E,E,11,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,"read",E,E,11,[[["self"],["u32"]],[R[6]]]],[11,"write",E,E,11,[[["self"]],[R[6]]]],[11,R[25],E,E,11,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[27],E,E,11,[[["self"],["rc",["btor"]],["btor"]]]],[11,R[23],R[51],E,12,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,R[24],E,E,12,[[["btor"],[R[9],["str"]],["rc",["btor"]],["str"],["bool"]],["self"]]],[11,"read",E,E,12,[[["self"],["u32"]],[R[6]]]],[11,"write",E,E,12,[[["self"]],[R[6]]]],[11,R[25],E,E,12,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[27],E,E,12,[[["self"],["rc",["btor"]],["btor"]]]],[11,"from",R[12],E,2,[[[R[16]]],[R[54]]]],[11,"next",E,E,9,[[["self"]],[R[9]]]],[11,"cmp",E,E,2,[[["self"],[R[54]]],[R[55]]]],[11,"partial_cmp",E,E,2,[[["self"],[R[54]]],[[R[55]],[R[9],[R[55]]]]]],[11,"lt",E,E,2,[[["self"],[R[54]]],["bool"]]],[11,"le",E,E,2,[[["self"],[R[54]]],["bool"]]],[11,"gt",E,E,2,[[["self"],[R[54]]],["bool"]]],[11,"ge",E,E,2,[[["self"],[R[54]]],["bool"]]],[11,"default",E,"Default values for all configuration parameters.",3,[[],["self"]]],[11,"default",E,"Provides predefined hooks for common functions. (At the…",10,[[],["self"]]],[11,"clone",E,E,3,[[["self"]],[R[1]]]],[11,"clone",E,E,4,[[["self"]],[R[56]]]],[11,"clone",E,E,10,[[["self"]],["functionhooks"]]],[11,"clone",E,E,0,[[["self"]],["state"]]],[11,"clone",E,E,2,[[["self"]],[R[54]]]],[11,"clone",E,E,1,[[["self"]],[R[16]]]],[11,"clone",R[50],E,11,[[["self"]],[R[59]]]],[11,"clone",R[51],E,12,[[["self"]],[R[59]]]],[11,"clone",R[52],E,13,[[["self"]],[R[15]]]],[11,"clone",E,E,14,[[["self"]],[R[57]]]],[11,"clone",R[12],E,5,[[["self"]],[R[60]]]],[11,"clone",E,E,6,[[["self"]],[R[8]]]],[11,"clone",R[53],E,19,[[["self"]],[R[3]]]],[11,"clone",E,E,20,[[["self"]],[R[61]]]],[11,"clone",R[12],E,7,[[["self"]],[R[58]]]],[11,"eq",E,E,4,[[["self"],[R[56]]],["bool"]]],[11,"ne",E,E,4,[[["self"],[R[56]]],["bool"]]],[11,"eq",E,E,2,[[["self"],[R[54]]],["bool"]]],[11,"ne",E,E,2,[[["self"],[R[54]]],["bool"]]],[11,"eq",E,E,1,[[["self"]],["bool"]]],[11,"eq",R[50],E,11,[[["self"]],["bool"]]],[11,"eq",R[51],E,12,[[["self"],[R[59]]],["bool"]]],[11,"ne",E,E,12,[[["self"],[R[59]]],["bool"]]],[11,"eq",R[52],E,13,[[["self"],[R[15]]],["bool"]]],[11,"ne",E,E,13,[[["self"],[R[15]]],["bool"]]],[11,"eq",E,E,14,[[["self"],[R[57]]],["bool"]]],[11,"ne",E,E,14,[[["self"],[R[57]]],["bool"]]],[11,"eq",R[12],E,5,[[["self"],[R[60]]],["bool"]]],[11,"ne",E,E,5,[[["self"],[R[60]]],["bool"]]],[11,"eq",E,E,6,[[["self"],[R[8]]],["bool"]]],[11,"ne",E,E,6,[[["self"],[R[8]]],["bool"]]],[11,"eq",R[53],E,19,[[["self"],[R[3]]],["bool"]]],[11,"eq",E,E,20,[[["self"],[R[61]]],["bool"]]],[11,"eq",R[12],E,7,[[["self"],[R[58]]],["bool"]]],[11,"ne",E,E,7,[[["self"],[R[58]]],["bool"]]],[11,"fmt",E,E,6,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",E,E,4,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",E,E,2,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",E,E,1,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",R[50],E,11,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",R[51],E,12,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",R[52],E,13,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",E,E,14,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",R[12],E,5,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",E,E,6,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",R[53],E,19,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",E,E,20,[[["self"],[R[62]]],[R[6]]]],[11,"fmt",R[12],E,7,[[["self"],[R[62]]],[R[6]]]],[11,"hash",E,E,2,[[["self"],["__h"]]]]],"p":[[3,"State"],[3,R[63]],[3,R[64]],[3,"Config"],[4,R[65]],[4,R[66]],[4,"Error"],[4,R[67]],[3,"Project"],[3,R[68]],[3,R[69]],[3,R[70]],[3,R[70]],[4,R[71]],[4,R[72]],[8,"Backend"],[8,R[41]],[8,"BV"],[8,R[70]],[3,R[73]],[3,R[74]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);