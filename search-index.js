var N=null,E="",T="t",U="u",searchIndex={};
var R=["bbname","string","config","backend","btorbackend","project","option","returnvalue","result","Construct a new `Project` from a path to a directory…","Get the size of the `Type`, in bits.","Get the offset (in bytes) of the element at the given…","function_hooks","Removes the function hook for the given function, which…","haybale","operand","Returns `true` if under the current constraints, `a` and…","bvsolution","possiblesolutions","callsite","A new `Memory`, whose contents at all addresses are…","INDEX_BITS","CELL_BITS","BITS_IN_BYTE","LOG_BITS_IN_BYTE","CELL_BYTES","new_uninitialized","new_zero_initialized","get_solver","Get a reference to the `Btor` instance this `Memory`…","change_solver","Adapt the `Memory` to a new `Btor` instance.","Read any number (>0) of bits of memory, at any alignment.…","Write any number (>0) of bits of memory, at any alignment.","Add a memory watchpoint. It will be enabled unless/until…","watchpoint","Remove the memory watchpoint with the given `name`.","Enable the memory watchpoint(s) with the given name.","Returns `true` if current constraints are satisfiable,…","sat_with_extra_constraints","bvs_must_be_equal","bvs_can_be_equal","get_possible_solutions_for_bv","Get a description of the possible solutions for the `BV`.","max_possible_solution_for_bv","Get the maximum possible solution for the `BV`: that is,…","min_possible_solution_for_bv","Get the minimum possible solution for the `BV`: that is,…","SolverRef","try_from","try_into","borrow_mut","to_owned","clone_into","type_id","borrow","typeid","haybale::function_hooks","haybale::memory","haybale::simple_memory","haybale::watchpoints","to_string","haybale::solver_utils","haybale::backend","location","concretize","demangling","pathentry","watchpoints","solutioncount","solutionvalue","default","memory","simplememorybackend","ordering","formatter","Location","PathEntry","Concretize","Demangling","ReturnValue","SolutionValue","ExecutionManager","FunctionHooks","Memory","Watchpoint","Watchpoints","PossibleSolutions","SolutionCount","BtorBackend","SimpleMemoryBackend"];

searchIndex["haybale"]={"doc":"For an introduction to the crate and how to get started,…","i":[[3,"Project",R[14],"A `Project` is a collection of LLVM code to be explored,…",N,N],[3,"State",E,"A `State` describes the full program state at a given…",N,N],[12,"solver",E,"Reference to the solver instance being used",0,N],[12,R[2],E,"The configuration being used",0,N],[12,"cur_loc",E,"Indicates the instruction which is currently being executed",0,N],[3,R[76],E,"Fully describes a code location within the LLVM IR.",N,N],[12,"module",E,E,1,N],[12,"func",E,E,1,N],[12,R[0],E,E,1,N],[12,"instr",E,"Index of the instruction within the basic block. E.g., 0…",1,N],[3,R[77],E,"Describes one segment of a path through the LLVM IR.",N,N],[12,"modname",E,E,2,N],[12,"funcname",E,E,2,N],[12,R[0],E,E,2,N],[12,"instr",E,"Index of the instruction within the basic block at which…",2,N],[3,R[82],E,"An `ExecutionManager` allows you to symbolically explore…",N,N],[3,"Config",E,"Various settings which affect how the symbolic execution…",N,N],[12,"loop_bound",E,"Maximum number of times to execute any given line of LLVM…",3,N],[12,"null_detection",E,"If `true`, all memory accesses will be checked to ensure…",3,N],[12,"concretize_memcpy_lengths",E,"When encountering a `memcpy`, `memset`, or `memmove` with…",3,N],[12,R[12],E,"The set of currently active function hooks; see…",3,N],[12,"initial_mem_watchpoints",E,"The initial memory watchpoints when a `State` is created…",3,N],[12,R[66],E,"Controls the (attempted) demangling of function names in…",3,N],[4,R[78],E,E,N,N],[13,"Symbolic",E,"Handle everything fully symbolically - that is, have the…",4,N],[13,"Arbitrary",E,"Pick one possible value arbitrarily. Often this may choose…",4,N],[13,"Prefer",E,"Prefer the given `u64` value if it is a possible value.…",4,N],[13,"Maximum",E,"Choose the maximum possible value. `Maximum` will be…",4,N],[13,"Minimum",E,"Choose the minimum possible value. `Minimum` will be…",4,N],[4,R[79],E,E,N,N],[13,"None",E,"Don't try to demangle",5,N],[13,"CPP",E,"Try to demangle using the C++ demangler (suitable for…",5,N],[13,"Rust",E,"Try to demangle using the Rust demangler (suitable for…",5,N],[4,R[80],E,"A simple enum describing the value returned from a function",N,N],[13,"Return",E,"The function or call returns this value",6,N],[13,"ReturnVoid",E,"The function or call returns void",6,N],[13,"Throw",E,"The function or call throws this value (using the LLVM…",6,N],[13,"Abort",E,"The function or call aborts without ever returning (e.g.,…",6,N],[4,"Error",E,"Error types used throughout this crate",N,N],[13,"Unsat",E,"While performing an operation, we discovered the current…",7,N],[13,"LoopBoundExceeded",E,"The current path has exceeded the configured `loop_bound`…",7,N],[13,"NullPointerDereference",E,"The current path has attempted to dereference a null…",7,N],[13,"FunctionNotFound",E,"Processing a call of a function with the given name, but…",7,N],[13,"BoolCoercionError",E,"An operation attempted to coerce a `BV` more than one bit…",7,N],[13,"SolverError",E,"The solver returned this processing error while evaluating…",7,N],[13,"UnsupportedInstruction",E,"Encountered an LLVM instruction which is not currently…",7,N],[13,"MalformedInstruction",E,"Encountered an LLVM instruction which was malformed, or at…",7,N],[13,"OtherError",E,"Some kind of error which doesn't fall into one of the…",7,N],[4,R[81],E,"A simple enum describing either an integer value or a…",N,N],[13,"I8",E,E,8,N],[13,"I16",E,E,8,N],[13,"I32",E,E,8,N],[13,"I64",E,E,8,N],[13,"Ptr",E,E,8,N],[5,"pretty_bb_name",E,"Format a basic block `Name` into a concise representation…",N,[[["name"]],[R[1]]]],[5,"pretty_var_name",E,"Format a variable `Name` into a concise representation for…",N,[[["name"]],[R[1]]]],[5,"symex_function",E,"Begin symbolic execution of the function named `funcname`,…",N,[[["str"],[R[3]],[R[2]],[R[5]]],[["executionmanager"],[R[3]]]]],[5,"find_zero_of_func",E,"Given a function, find values of its inputs such that it…",N,[[["str"],[R[2],[R[4]]],[R[4]],[R[5]]],[["vec",[R[70]]],[R[6],["vec"]]]]],[5,"get_possible_return_values_of_func",E,"Get a description of the possible return values of a…",N,[[[R[5]],["u32"],[R[4]],["str"],[R[2],[R[4]]],["usize"],[R[6],["u32"]]],[[R[18],[R[7]]],[R[7],["u64"]]]]],[11,"from_bc_path",E,"Construct a new `Project` from a path to an LLVM bitcode…",9,[[],[[R[8],[R[1]]],[R[1]]]]],[11,"from_bc_paths",E,"Construct a new `Project` from multiple LLVM bitcode files",9,[[],[[R[8],[R[1]]],[R[1]]]]],[11,"from_bc_dir",E,R[9],9,[[["str"]],[[R[8],["error"]],["error"]]]],[11,"from_bc_dir_with_blacklist",E,R[9],9,[[["str"]],[[R[8],["error"]],["error"]]]],[11,"add_bc_path",E,"Add the code in the given LLVM bitcode file to the `Project`",9,[[["self"]],[[R[8],[R[1]]],[R[1]]]]],[11,"add_bc_dir",E,"Add the code in the given directory to the `Project`. See…",9,[[["str"],["self"]],[[R[8],["error"]],["error"]]]],[11,"add_bc_dir_with_blacklist",E,"Add the code in the given directory, except for…",9,[[["str"],["self"]],[[R[8],["error"]],["error"]]]],[11,"all_functions",E,"Iterate over all `Function`s in the `Project`. Gives pairs…",9,[[["self"]]]],[11,"all_global_vars",E,"Iterate over all `GlobalVariable`s in the `Project`. Gives…",9,[[["self"]]]],[11,"all_global_aliases",E,"Iterate over all `GlobalAlias`es in the `Project`. Gives…",9,[[["self"]]]],[11,"all_named_struct_types",E,"Iterate over all named struct types in the `Project`.…",9,[[["self"]]]],[11,"active_module_names",E,"Get the names of the LLVM modules which have been parsed…",9,[[["self"]]]],[11,"get_func_by_name",E,"Search the project for a function with the given name. If…",9,[[["str"],["self"]],[R[6]]]],[11,"get_named_struct_type_by_name",E,"Search the project for a named struct type with the given…",9,[[["str"],["self"]],[R[6]]]],[11,"get_inner_struct_type_from_named",E,"Given a `NamedStructType`, get the `StructType`…",9,[[["type"],["self"]],[[R[6],["arc"]],["arc",["rwlock"]]]]],[11,"state",E,"Provides access to the `State` resulting from the end of…",10,[[["self"]],["state"]]],[11,"mut_state",E,"Provides mutable access to the underlying `State` (see…",10,[[["self"]],["state"]]],[11,"param_bvs",E,"Provides access to the `BV` objects representing each of…",10,[[["self"]],["vec"]]],[0,"layout",E,"Functions related to the in-memory layout of data types.",N,N],[5,"size","haybale::layout",R[10],N,[[["type"]],["usize"]]],[5,"size_opaque_aware",E,R[10],N,[[[R[5]],["type"]],["usize"]]],[5,"fp_size",E,"Get the size of the `FPType`, in bits",N,[[["fptype"]],["usize"]]],[5,"get_offset_constant_index",E,R[11],N,[[["type"],["usize"]],[R[8]]]],[5,"get_offset_bv_index",E,R[11],N,[[["type"],["v"]],[R[8]]]],[17,"POINTER_SIZE_BITS",E,"our convention is that pointers are 64 bits",N,N],[11,"new",R[14],"Creates a new `Config` with the given `loop_bound` and…",3,[[[R[65]],["usize"],["bool"]],["self"]]],[11,"maybe_demangle",E,"Attempts to demangle the given function name, as…",5,[[["str"],["self"]],[R[1]]]],[0,R[12],E,"Functions and structures for defining and activating…",N,N],[3,R[83],R[57],"A set of function hooks, which will be executed instead of…",N,N],[5,"generic_stub_hook",E,"This hook ignores the function arguments and returns an…",N,[[[R[5]],["state"],["iscall"]],[[R[7]],[R[8],[R[7]]]]]],[5,"abort_hook",E,"This hook ignores the function arguments and returns…",N,[[[R[5]],["state"],["iscall"]],[[R[7]],[R[8],[R[7]]]]]],[6,"Argument",E,"An `Argument` represents a single argument to a called…",N,N],[8,"IsCall",E,"`IsCall` exists to unify the commonalities between LLVM…",N,N],[10,"get_called_func",E,E,11,[[["self"]],["either"]]],[10,"get_arguments",E,E,11,[[["self"]],["vec"]]],[10,"get_return_attrs",E,E,11,[[["self"]],["vec"]]],[10,"get_fn_attrs",E,E,11,[[["self"]],["vec"]]],[10,"get_calling_convention",E,E,11,[[["self"]],["callingconvention"]]],[11,"new",E,"Create a blank `FunctionHooks` instance with no function…",12,[[],["self"]]],[11,"add",E,"Adds a function hook. The `hook` will be executed instead…",12,[[["self"],["h"]]]],[11,"add_cpp_demangled",E,"Exactly like `add()`, but takes the (C++) demangled name…",12,[[["self"],["h"]]]],[11,"add_rust_demangled",E,"Exactly like `add()`, but takes the (Rust) demangled name…",12,[[["self"],["h"]]]],[11,"add_inline_asm_hook",E,"Add a hook to be used for calls to inline assembly. This…",12,[[["self"],["h"]],["bool"]]],[11,"remove",E,R[13],12,[[["str"],["self"]]]],[11,"remove_cpp_demangled",E,R[13],12,[[["str"],["self"]]]],[11,"remove_rust_demangled",E,R[13],12,[[["str"],["self"]]]],[11,"remove_inline_asm_hook",E,"Removes the function hook used for calls to inline…",12,[[["self"]]]],[11,"is_hooked",E,"Determine whether there is an active hook for the given…",12,[[["str"],["self"]],["bool"]]],[0,"alloc_utils",R[14],"Utility functions for performing memory allocation. These…",N,N],[5,"malloc","haybale::alloc_utils","Allocate a number of bytes given by the `Operand`.",N,[[["state"],[R[15]]],[R[8]]]],[5,"zalloc",E,"Allocate a number of bytes given by the `Operand`. The…",N,[[["state"],[R[15]]],[R[8]]]],[5,"calloc",E,"Allocate a number of bytes given by `a` times `b`, where…",N,[[["state"],[R[15]]],[R[8]]]],[5,"realloc",E,"Reallocate the given `addr` to be at least the number of…",N,[[["state"],[R[15]]],[R[8]]]],[11,"new",R[14],"`start_loc`: the `Location` where the `State` should begin…",0,[[[R[64]],[R[2]],[R[5]]],["self"]]],[11,"fork",E,"Fully duplicate the `State`. Unlike with `clone()`, the…",0,[[["self"]],["self"]]],[11,"sat",E,R[38],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[39],E,"Returns `true` if the current constraints plus the given…",0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[40],E,R[16],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[41],E,R[16],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,"get_a_solution_for_bv",E,"Get one possible concrete value for the `BV`. Returns…",0,[[["self"]],[[R[6],[R[17]]],[R[8],[R[6]]]]]],[11,"get_a_solution_for_irname",E,"Get one possible concrete value for the given IR `Name`…",0,[[["name"],["self"],[R[1]]],[[R[6],[R[17]]],[R[8],[R[6]]]]]],[11,R[42],E,R[43],0,[[["usize"],["self"]],[[R[8],[R[18]]],[R[18],[R[17]]]]]],[11,"get_possible_solutions_for_irname",E,"Get a description of the possible solutions for the given…",0,[[["name"],[R[1]],["usize"],["self"]],[[R[8],[R[18]]],[R[18],[R[17]]]]]],[11,R[44],E,R[45],0,[[["self"]],[[R[8],[R[6]]],[R[6],["u64"]]]]],[11,"max_possible_solution_for_irname",E,"Get the maximum possible solution for the given IR `Name`…",0,[[["name"],["self"],[R[1]]],[[R[8],[R[6]]],[R[6],["u64"]]]]],[11,R[46],E,R[47],0,[[["self"]],[[R[8],[R[6]]],[R[6],["u64"]]]]],[11,"min_possible_solution_for_irname",E,"Get the minimum possible solution for the given IR `Name`…",0,[[["name"],[R[1]],["self"]],[[R[8],[R[6]]],[R[6],["u64"]]]]],[11,"bv_from_bool",E,"Create a `BV` constant representing the given `bool`…",0,[[["self"],["bool"]]]],[11,"bv_from_i32",E,"Create a `BV` representing the given constant `i32` value,…",0,[[["u32"],["self"],["i32"]]]],[11,"bv_from_u32",E,"Create a `BV` representing the given constant `u32` value,…",0,[[["u32"],["self"]]]],[11,"bv_from_i64",E,"Create a `BV` representing the given constant `i64` value,…",0,[[["i64"],["u32"],["self"]]]],[11,"bv_from_u64",E,"Create a `BV` representing the given constant `u64` value,…",0,[[["u32"],["self"],["u64"]]]],[11,"zero",E,"Create a `BV` representing the constant `0` of the given…",0,[[["u32"],["self"]]]],[11,"one",E,"Create a `BV` representing the constant `1` of the given…",0,[[["u32"],["self"]]]],[11,"ones",E,"Create a `BV` constant of the given width, where all bits…",0,[[["u32"],["self"]]]],[11,"new_bv_with_name",E,"Create a new (unconstrained) `BV` for the given `Name` (in…",0,[[["name"],["self"],["u32"]],[R[8]]]],[11,"assign_bv_to_name",E,"Assign the given `BV` to the given `Name` (in the current…",0,[[["name"],["self"]],[R[8]]]],[11,"record_bv_result",E,"Record the result of `thing` to be `resultval`. Assumes…",0,[[["self"]],[R[8]]]],[11,"overwrite_latest_version_of_bv",E,"Overwrite the latest version of the given `Name` to…",0,[[["name"],["self"]]]],[11,"operand_to_bv",E,"Convert an `Operand` to the appropriate `BV`. Assumes the…",0,[[["self"],[R[15]]],[R[8]]]],[11,"const_to_bv",E,"Convert a `Constant` to the appropriate `BV`.",0,[[["constant"],["self"]],[R[8]]]],[11,"get_pointer_to_function",E,"Get a pointer to the given function name. The name will be…",0,[[["self"]],[R[6]]]],[11,"get_pointer_to_function_hook",E,"Get a pointer to the currently active hook for the given…",0,[[["str"],["self"]],[R[6]]]],[11,"read",E,"Read a value `bits` bits long from memory at `addr`. Note…",0,[[["u32"],["self"]],[R[8]]]],[11,"write",E,"Write a value into memory at `addr`. Note that `val` can…",0,[[["self"]],[R[8]]]],[11,"add_mem_watchpoint",E,R[34],0,[[["self"],[R[35]]],["bool"]]],[11,"rm_mem_watchpoint",E,R[36],0,[[["str"],["self"]],["bool"]]],[11,"disable_watchpoint",E,"Disable the memory watchpoint with the given `name`.…",0,[[["str"],["self"]],["bool"]]],[11,"enable_watchpoint",E,R[37],0,[[["str"],["self"]],["bool"]]],[11,"allocate",E,"Allocate a value of size `bits`; return a pointer to the…",0,[[["self"]]]],[11,"get_allocation_size",E,"Get the size, in bits, of the allocation at the given…",0,[[["self"]],[[R[8],[R[6]]],[R[6],["u64"]]]]],[11,"record_path_entry",E,"Record the current location as a `PathEntry` in the…",0,[[["self"]]]],[11,"get_path",E,"Get the `PathEntry`s that have been recorded, in order",0,[[["self"]],["vec"]]],[11,"push_callsite",E,"Record entering a normal `Call` at the current location",0,[[["self"],["call"]]]],[11,"push_invokesite",E,"Record entering the given `Invoke` at the current location",0,[[["self"],["invoke"]]]],[11,"pop_callsite",E,"Record leaving the current function. Returns the…",0,[[["self"]],[[R[6],[R[19]]],[R[19]]]]],[11,"save_backtracking_point",E,"Save the current state, about to enter the `BasicBlock`…",0,[[["name"],["self"]]]],[11,"revert_to_backtracking_point",E,"returns `Ok(true)` if the operation was successful,…",0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,"count_backtracking_points",E,"returns the number of saved backtracking points",0,[[["self"]],["usize"]]],[11,"pretty_llvm_backtrace",E,"returns a `String` containing a formatted view of the…",0,[[["self"]],[R[1]]]],[11,"all_vars_in_cur_fn",E,"Get the most recent `BV` created for each `Name` in the…",0,[[["self"]]]],[11,"current_assignments_as_pretty_string",E,"returns a `String` describing a set of satisfying…",0,[[["self"]],[[R[1]],[R[8],[R[1]]]]]],[0,R[72],E,"Implementation of a `Memory` based on a Boolector array…",N,N],[3,R[84],R[58],E,N,N],[18,R[21],E,E,13,N],[18,R[22],E,E,13,N],[18,R[23],E,E,13,N],[18,R[24],E,E,13,N],[18,R[25],E,E,13,N],[18,"LOG_CELL_BYTES",E,E,13,N],[18,"CELL_OFFSET_MASK",E,E,13,N],[11,R[26],E,R[20],13,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,R[27],E,R[20],13,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,R[28],E,R[29],13,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[30],E,R[31],13,[[["btor"],["self"],["rc",["btor"]]]]],[11,"read",E,R[32],13,[[["bv"],["u32"],["self"]],[["bv",["rc"]],[R[8],["bv"]]]]],[11,"write",E,R[33],13,[[["bv"],["self"],["bv",["rc"]],["rc",["btor"]]],[R[8]]]],[0,"simple_memory",R[14],"Simple implementation of a `Memory` based on a Boolector…",N,N],[3,R[84],R[59],E,N,N],[18,R[21],E,E,14,N],[18,R[22],E,E,14,N],[18,R[23],E,E,14,N],[18,R[24],E,E,14,N],[18,R[25],E,E,14,N],[11,R[26],E,R[20],14,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,R[27],E,R[20],14,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,R[28],E,R[29],14,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[30],E,R[31],14,[[["btor"],["self"],["rc",["btor"]]]]],[11,"read",E,R[32],14,[[["bv"],["u32"],["self"]],[["bv",["rc"]],[R[8],["bv"]]]]],[11,"write",E,R[33],14,[[["bv"],["self"],["bv",["rc"]],["rc",["btor"]]],[R[8]]]],[0,R[68],R[14],"Structures for defining and processing memory watchpoints",N,N],[3,R[85],R[60],"A `Watchpoint` describes a segment of memory to watch.",N,N],[3,R[86],E,"Stores information about watchpoints and performs…",N,N],[11,"new",E,"A memory watchpoint for the `bytes` bytes of memory at the…",15,[[["u64"]],["self"]]],[11,"new",E,"Construct a new `Watchpoints` instance with no watchpoints.",16,[[],["self"]]],[11,"add",E,R[34],16,[[["self"],[R[35]]],["bool"]]],[11,"remove",E,R[36],16,[[["str"],["self"]],["bool"]]],[11,"disable",E,"Disable the memory watchpoint with the given `name`.",16,[[["str"],["self"]],["bool"]]],[11,"enable",E,R[37],16,[[["str"],["self"]],["bool"]]],[0,"solver_utils",R[14],"Simple utilities for interacting with the solver",N,N],[4,R[87],R[62],E,N,N],[13,"Exactly",E,"This is exactly the set of possible solutions; there are…",17,N],[13,"AtLeast",E,"All of the solutions in this set are possible solutions,…",17,N],[4,R[88],E,E,N,N],[13,"Exactly",E,"There are exactly this many solutions",18,N],[13,"AtLeast",E,"There are at least this many solutions",18,N],[5,"sat",E,R[38],N,[[["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[39],E,"Returns `true` if the current constraints plus the…",N,[[["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[40],E,R[16],N,[[["v"],["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[41],E,R[16],N,[[["v"],["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[42],E,R[43],N,[[["v"],["usize"]],[[R[8],[R[18]]],[R[18],[R[17]]]]]],[5,R[44],E,R[45],N,[[["v"]],[[R[8],[R[6]]],[R[6],["u64"]]]]],[5,R[46],E,R[47],N,[[["v"]],[[R[8],[R[6]]],[R[6],["u64"]]]]],[11,"as_u64_solutions",E,"Convert a `PossibleSolutions` over `BVSolution` into a…",17,[[["self"]],[[R[18],["u64"]],[R[6],[R[18]]]]]],[11,"count",E,"Get a count of how many possible solutions there are.",17,[[["self"]],[R[69]]]],[0,R[3],R[14],"Traits which abstract over the backend (BV types, memory…",N,N],[3,R[89],R[63],E,N,N],[3,R[90],E,E,N,N],[8,"Backend",E,"A `Backend` is just a collection of types which together…",N,N],[16,R[48],E,E,19,N],[16,"BV",E,E,19,N],[16,R[84],E,E,19,N],[8,R[48],E,"Trait for something which acts as a reference to a…",N,N],[16,"BV",E,E,20,N],[16,"Array",E,E,20,N],[10,"new",E,"Create a new `Btor` instance, initialize it as necessary,…",20,[[],["self"]]],[10,"duplicate",E,"As opposed to `clone()` which merely clones the reference,…",20,[[["self"]],["self"]]],[10,"match_bv",E,"Given a `BV` originally created for any `SolverRef`, get…",20,[[["self"]],[R[6]]]],[10,"match_array",E,"Given an `Array` originally created for any `SolverRef`,…",20,[[["self"]],[R[6]]]],[8,"BV",E,"Trait for things which can act like bitvectors",N,N],[16,R[48],E,E,21,N],[10,"new",E,E,21,[[["str"],["u32"],[R[6],["str"]]],["self"]]],[10,"from_bool",E,E,21,[[["bool"]],["self"]]],[10,"from_i32",E,E,21,[[["i32"],["u32"]],["self"]]],[10,"from_u32",E,E,21,[[["u32"]],["self"]]],[10,"from_i64",E,E,21,[[["i64"],["u32"]],["self"]]],[10,"from_u64",E,E,21,[[["u32"],["u64"]],["self"]]],[10,"zero",E,E,21,[[["u32"]],["self"]]],[10,"one",E,E,21,[[["u32"]],["self"]]],[10,"ones",E,E,21,[[["u32"]],["self"]]],[10,"from_binary_str",E,E,21,[[["str"]],["self"]]],[10,"from_dec_str",E,E,21,[[["str"],["u32"]],["self"]]],[10,"from_hex_str",E,E,21,[[["str"],["u32"]],["self"]]],[10,"as_binary_str",E,E,21,[[["self"]],[[R[6],[R[1]]],[R[1]]]]],[10,"as_u64",E,E,21,[[["self"]],[[R[6],["u64"]],["u64"]]]],[10,"as_bool",E,E,21,[[["self"]],[[R[6],["bool"]],["bool"]]]],[10,"get_a_solution",E,E,21,[[["self"]],[[R[17]],[R[8],[R[17]]]]]],[10,"get_id",E,E,21,[[["self"]],["i32"]]],[10,"get_width",E,E,21,[[["self"]],["u32"]]],[10,"get_symbol",E,E,21,[[["self"]],[["str"],[R[6],["str"]]]]],[10,"set_symbol",E,E,21,[[["str"],["self"],[R[6],["str"]]]]],[10,"is_const",E,E,21,[[["self"]],["bool"]]],[10,"has_same_width",E,E,21,[[["self"]],["bool"]]],[10,"assert",E,E,21,[[["self"]],[R[8]]]],[10,"is_failed_assumption",E,E,21,[[["self"]],["bool"]]],[10,"_eq",E,E,21,[[["self"]],["self"]]],[10,"_ne",E,E,21,[[["self"]],["self"]]],[10,"add",E,E,21,[[["self"]],["self"]]],[10,"sub",E,E,21,[[["self"]],["self"]]],[10,"mul",E,E,21,[[["self"]],["self"]]],[10,"udiv",E,E,21,[[["self"]],["self"]]],[10,"sdiv",E,E,21,[[["self"]],["self"]]],[10,"urem",E,E,21,[[["self"]],["self"]]],[10,"srem",E,E,21,[[["self"]],["self"]]],[10,"smod",E,E,21,[[["self"]],["self"]]],[10,"inc",E,E,21,[[["self"]],["self"]]],[10,"dec",E,E,21,[[["self"]],["self"]]],[10,"neg",E,E,21,[[["self"]],["self"]]],[10,"uaddo",E,E,21,[[["self"]],["self"]]],[10,"saddo",E,E,21,[[["self"]],["self"]]],[10,"usubo",E,E,21,[[["self"]],["self"]]],[10,"ssubo",E,E,21,[[["self"]],["self"]]],[10,"umulo",E,E,21,[[["self"]],["self"]]],[10,"smulo",E,E,21,[[["self"]],["self"]]],[10,"sdivo",E,E,21,[[["self"]],["self"]]],[10,"not",E,E,21,[[["self"]],["self"]]],[10,"and",E,E,21,[[["self"]],["self"]]],[10,"or",E,E,21,[[["self"]],["self"]]],[10,"xor",E,E,21,[[["self"]],["self"]]],[10,"nand",E,E,21,[[["self"]],["self"]]],[10,"nor",E,E,21,[[["self"]],["self"]]],[10,"xnor",E,E,21,[[["self"]],["self"]]],[10,"sll",E,E,21,[[["self"]],["self"]]],[10,"srl",E,E,21,[[["self"]],["self"]]],[10,"sra",E,E,21,[[["self"]],["self"]]],[10,"rol",E,E,21,[[["self"]],["self"]]],[10,"ror",E,E,21,[[["self"]],["self"]]],[10,"redand",E,E,21,[[["self"]],["self"]]],[10,"redor",E,E,21,[[["self"]],["self"]]],[10,"redxor",E,E,21,[[["self"]],["self"]]],[10,"ugt",E,E,21,[[["self"]],["self"]]],[10,"ugte",E,E,21,[[["self"]],["self"]]],[10,"sgt",E,E,21,[[["self"]],["self"]]],[10,"sgte",E,E,21,[[["self"]],["self"]]],[10,"ult",E,E,21,[[["self"]],["self"]]],[10,"ulte",E,E,21,[[["self"]],["self"]]],[10,"slt",E,E,21,[[["self"]],["self"]]],[10,"slte",E,E,21,[[["self"]],["self"]]],[10,"zext",E,E,21,[[["u32"],["self"]],["self"]]],[10,"sext",E,E,21,[[["u32"],["self"]],["self"]]],[10,"slice",E,E,21,[[["u32"],["self"]],["self"]]],[10,"concat",E,E,21,[[["self"]],["self"]]],[10,"repeat",E,E,21,[[["u32"],["self"]],["self"]]],[10,"iff",E,E,21,[[["self"]],["self"]]],[10,"implies",E,E,21,[[["self"]],["self"]]],[10,"cond_bv",E,E,21,[[["self"]],["self"]]],[8,R[84],E,"Trait for things which can act like 'memories', that is,…",N,N],[16,R[48],E,E,22,N],[16,"Index",E,E,22,N],[16,"Value",E,E,22,N],[10,R[26],E,R[20],22,[[["str"],[R[6],["str"]],["bool"]],["self"]]],[10,R[27],E,R[20],22,[[["str"],[R[6],["str"]],["bool"]],["self"]]],[10,"read",E,R[32],22,[[["u32"],["self"]],[R[8]]]],[10,"write",E,R[33],22,[[["self"]],[R[8]]]],[10,R[28],E,"Get a reference to the solver instance this `Memory`…",22,[[["self"]]]],[10,R[30],E,"Adapt the `Memory` to a new solver instance.",22,[[["self"]]]],[6,"Result",R[14],"A type alias for convenience, similar to how…",N,N],[11,"unwrap_to_i8",E,E,8,[[],["i8"]]],[11,"unwrap_to_i16",E,E,8,[[],["i16"]]],[11,"unwrap_to_i32",E,E,8,[[],["i32"]]],[11,"unwrap_to_i64",E,E,8,[[],["i64"]]],[11,"unwrap_to_ptr",E,E,8,[[],["u64"]]],[11,"into",E,E,9,[[],[U]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[49],E,E,9,[[[U]],[R[8]]]],[11,R[50],E,E,9,[[],[R[8]]]],[11,R[55],E,E,9,[[["self"]],[T]]],[11,R[51],E,E,9,[[["self"]],[T]]],[11,R[54],E,E,9,[[["self"]],[R[56]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[52],E,E,0,[[["self"]],[T]]],[11,R[53],E,E,0,[[["self"],[T]]]],[11,R[49],E,E,0,[[[U]],[R[8]]]],[11,R[50],E,E,0,[[],[R[8]]]],[11,R[55],E,E,0,[[["self"]],[T]]],[11,R[51],E,E,0,[[["self"]],[T]]],[11,R[54],E,E,0,[[["self"]],[R[56]]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[52],E,E,1,[[["self"]],[T]]],[11,R[53],E,E,1,[[["self"],[T]]]],[11,R[49],E,E,1,[[[U]],[R[8]]]],[11,R[50],E,E,1,[[],[R[8]]]],[11,R[55],E,E,1,[[["self"]],[T]]],[11,R[51],E,E,1,[[["self"]],[T]]],[11,R[54],E,E,1,[[["self"]],[R[56]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[52],E,E,2,[[["self"]],[T]]],[11,R[53],E,E,2,[[["self"],[T]]]],[11,R[49],E,E,2,[[[U]],[R[8]]]],[11,R[50],E,E,2,[[],[R[8]]]],[11,R[55],E,E,2,[[["self"]],[T]]],[11,R[51],E,E,2,[[["self"]],[T]]],[11,R[54],E,E,2,[[["self"]],[R[56]]]],[11,"into",E,E,10,[[],[U]]],[11,"from",E,E,10,[[[T]],[T]]],[11,"into_iter",E,E,10,[[],["i"]]],[11,R[49],E,E,10,[[[U]],[R[8]]]],[11,R[50],E,E,10,[[],[R[8]]]],[11,R[55],E,E,10,[[["self"]],[T]]],[11,R[51],E,E,10,[[["self"]],[T]]],[11,R[54],E,E,10,[[["self"]],[R[56]]]],[11,"reduce",E,E,10,[[["f"]],[R[6]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[52],E,E,3,[[["self"]],[T]]],[11,R[53],E,E,3,[[["self"],[T]]]],[11,R[49],E,E,3,[[[U]],[R[8]]]],[11,R[50],E,E,3,[[],[R[8]]]],[11,R[55],E,E,3,[[["self"]],[T]]],[11,R[51],E,E,3,[[["self"]],[T]]],[11,R[54],E,E,3,[[["self"]],[R[56]]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[52],E,E,4,[[["self"]],[T]]],[11,R[53],E,E,4,[[["self"],[T]]]],[11,R[49],E,E,4,[[[U]],[R[8]]]],[11,R[50],E,E,4,[[],[R[8]]]],[11,R[55],E,E,4,[[["self"]],[T]]],[11,R[51],E,E,4,[[["self"]],[T]]],[11,R[54],E,E,4,[[["self"]],[R[56]]]],[11,"into",E,E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[52],E,E,5,[[["self"]],[T]]],[11,R[53],E,E,5,[[["self"],[T]]]],[11,R[49],E,E,5,[[[U]],[R[8]]]],[11,R[50],E,E,5,[[],[R[8]]]],[11,R[55],E,E,5,[[["self"]],[T]]],[11,R[51],E,E,5,[[["self"]],[T]]],[11,R[54],E,E,5,[[["self"]],[R[56]]]],[11,"into",E,E,6,[[],[U]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[52],E,E,6,[[["self"]],[T]]],[11,R[53],E,E,6,[[["self"],[T]]]],[11,R[49],E,E,6,[[[U]],[R[8]]]],[11,R[50],E,E,6,[[],[R[8]]]],[11,R[55],E,E,6,[[["self"]],[T]]],[11,R[51],E,E,6,[[["self"]],[T]]],[11,R[54],E,E,6,[[["self"]],[R[56]]]],[11,"into",E,E,7,[[],[U]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[52],E,E,7,[[["self"]],[T]]],[11,R[53],E,E,7,[[["self"],[T]]]],[11,R[61],E,E,7,[[["self"]],[R[1]]]],[11,R[49],E,E,7,[[[U]],[R[8]]]],[11,R[50],E,E,7,[[],[R[8]]]],[11,R[55],E,E,7,[[["self"]],[T]]],[11,R[51],E,E,7,[[["self"]],[T]]],[11,R[54],E,E,7,[[["self"]],[R[56]]]],[11,"into",E,E,8,[[],[U]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[52],E,E,8,[[["self"]],[T]]],[11,R[53],E,E,8,[[["self"],[T]]]],[11,R[49],E,E,8,[[[U]],[R[8]]]],[11,R[50],E,E,8,[[],[R[8]]]],[11,R[55],E,E,8,[[["self"]],[T]]],[11,R[51],E,E,8,[[["self"]],[T]]],[11,R[54],E,E,8,[[["self"]],[R[56]]]],[11,"into",R[57],E,12,[[],[U]]],[11,"from",E,E,12,[[[T]],[T]]],[11,R[52],E,E,12,[[["self"]],[T]]],[11,R[53],E,E,12,[[["self"],[T]]]],[11,R[49],E,E,12,[[[U]],[R[8]]]],[11,R[50],E,E,12,[[],[R[8]]]],[11,R[55],E,E,12,[[["self"]],[T]]],[11,R[51],E,E,12,[[["self"]],[T]]],[11,R[54],E,E,12,[[["self"]],[R[56]]]],[11,"into",R[58],E,13,[[],[U]]],[11,"from",E,E,13,[[[T]],[T]]],[11,R[52],E,E,13,[[["self"]],[T]]],[11,R[53],E,E,13,[[["self"],[T]]]],[11,R[49],E,E,13,[[[U]],[R[8]]]],[11,R[50],E,E,13,[[],[R[8]]]],[11,R[55],E,E,13,[[["self"]],[T]]],[11,R[51],E,E,13,[[["self"]],[T]]],[11,R[54],E,E,13,[[["self"]],[R[56]]]],[11,"into",R[59],E,14,[[],[U]]],[11,"from",E,E,14,[[[T]],[T]]],[11,R[52],E,E,14,[[["self"]],[T]]],[11,R[53],E,E,14,[[["self"],[T]]]],[11,R[49],E,E,14,[[[U]],[R[8]]]],[11,R[50],E,E,14,[[],[R[8]]]],[11,R[55],E,E,14,[[["self"]],[T]]],[11,R[51],E,E,14,[[["self"]],[T]]],[11,R[54],E,E,14,[[["self"]],[R[56]]]],[11,"into",R[60],E,15,[[],[U]]],[11,"from",E,E,15,[[[T]],[T]]],[11,R[52],E,E,15,[[["self"]],[T]]],[11,R[53],E,E,15,[[["self"],[T]]]],[11,R[61],E,E,15,[[["self"]],[R[1]]]],[11,R[49],E,E,15,[[[U]],[R[8]]]],[11,R[50],E,E,15,[[],[R[8]]]],[11,R[55],E,E,15,[[["self"]],[T]]],[11,R[51],E,E,15,[[["self"]],[T]]],[11,R[54],E,E,15,[[["self"]],[R[56]]]],[11,"into",E,E,16,[[],[U]]],[11,"from",E,E,16,[[[T]],[T]]],[11,R[52],E,E,16,[[["self"]],[T]]],[11,R[53],E,E,16,[[["self"],[T]]]],[11,R[49],E,E,16,[[[U]],[R[8]]]],[11,R[50],E,E,16,[[],[R[8]]]],[11,R[55],E,E,16,[[["self"]],[T]]],[11,R[51],E,E,16,[[["self"]],[T]]],[11,R[54],E,E,16,[[["self"]],[R[56]]]],[11,"into",R[62],E,17,[[],[U]]],[11,"from",E,E,17,[[[T]],[T]]],[11,R[52],E,E,17,[[["self"]],[T]]],[11,R[53],E,E,17,[[["self"],[T]]]],[11,R[49],E,E,17,[[[U]],[R[8]]]],[11,R[50],E,E,17,[[],[R[8]]]],[11,R[55],E,E,17,[[["self"]],[T]]],[11,R[51],E,E,17,[[["self"]],[T]]],[11,R[54],E,E,17,[[["self"]],[R[56]]]],[11,"into",E,E,18,[[],[U]]],[11,"from",E,E,18,[[[T]],[T]]],[11,R[52],E,E,18,[[["self"]],[T]]],[11,R[53],E,E,18,[[["self"],[T]]]],[11,R[49],E,E,18,[[[U]],[R[8]]]],[11,R[50],E,E,18,[[],[R[8]]]],[11,R[55],E,E,18,[[["self"]],[T]]],[11,R[51],E,E,18,[[["self"]],[T]]],[11,R[54],E,E,18,[[["self"]],[R[56]]]],[11,"into",R[63],E,23,[[],[U]]],[11,"from",E,E,23,[[[T]],[T]]],[11,R[52],E,E,23,[[["self"]],[T]]],[11,R[53],E,E,23,[[["self"],[T]]]],[11,R[49],E,E,23,[[[U]],[R[8]]]],[11,R[50],E,E,23,[[],[R[8]]]],[11,R[55],E,E,23,[[["self"]],[T]]],[11,R[51],E,E,23,[[["self"]],[T]]],[11,R[54],E,E,23,[[["self"]],[R[56]]]],[11,"into",E,E,24,[[],[U]]],[11,"from",E,E,24,[[[T]],[T]]],[11,R[52],E,E,24,[[["self"]],[T]]],[11,R[53],E,E,24,[[["self"],[T]]]],[11,R[49],E,E,24,[[[U]],[R[8]]]],[11,R[50],E,E,24,[[],[R[8]]]],[11,R[55],E,E,24,[[["self"]],[T]]],[11,R[51],E,E,24,[[["self"]],[T]]],[11,R[54],E,E,24,[[["self"]],[R[56]]]],[11,R[26],R[58],E,13,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,R[27],E,E,13,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,"read",E,E,13,[[["u32"],["self"]],[R[8]]]],[11,"write",E,E,13,[[["self"]],[R[8]]]],[11,R[28],E,E,13,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[30],E,E,13,[[["btor"],["self"],["rc",["btor"]]]]],[11,R[26],R[59],E,14,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,R[27],E,E,14,[[["str"],[R[6],["str"]],["btor"],["rc",["btor"]],["bool"]],["self"]]],[11,"read",E,E,14,[[["u32"],["self"]],[R[8]]]],[11,"write",E,E,14,[[["self"]],[R[8]]]],[11,R[28],E,E,14,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[30],E,E,14,[[["btor"],["self"],["rc",["btor"]]]]],[11,"from",R[14],E,2,[[[R[64]]],[R[67]]]],[11,"next",E,E,10,[[["self"]],[R[6]]]],[11,"clone",E,E,3,[[["self"]],[R[2]]]],[11,"clone",E,E,4,[[["self"]],[R[65]]]],[11,"clone",E,E,5,[[["self"]],[R[66]]]],[11,"clone",R[57],E,12,[[["self"]],["functionhooks"]]],[11,"clone",R[14],E,0,[[["self"]],["state"]]],[11,"clone",E,E,2,[[["self"]],[R[67]]]],[11,"clone",E,E,1,[[["self"]],[R[64]]]],[11,"clone",R[58],E,13,[[["self"]],[R[72]]]],[11,"clone",R[59],E,14,[[["self"]],[R[72]]]],[11,"clone",R[60],E,15,[[["self"]],[R[35]]]],[11,"clone",E,E,16,[[["self"]],[R[68]]]],[11,"clone",R[62],E,17,[[["self"]],[R[18]]]],[11,"clone",E,E,18,[[["self"]],[R[69]]]],[11,"clone",R[14],E,6,[[["self"]],[R[7]]]],[11,"clone",E,E,7,[[["self"]],["error"]]],[11,"clone",R[63],E,23,[[["self"]],[R[4]]]],[11,"clone",E,E,24,[[["self"]],[R[73]]]],[11,"clone",R[14],E,8,[[["self"]],[R[70]]]],[11,R[71],E,"Default values for all configuration parameters.",3,[[],["self"]]],[11,R[71],R[57],"Provides predefined hooks for common functions. (At the…",12,[[],["self"]]],[11,R[71],R[60],E,16,[[],[R[68]]]],[11,"cmp",R[14],E,2,[[[R[67]],["self"]],[R[74]]]],[11,"eq",E,E,4,[[[R[65]],["self"]],["bool"]]],[11,"ne",E,E,4,[[[R[65]],["self"]],["bool"]]],[11,"eq",E,E,5,[[["self"],[R[66]]],["bool"]]],[11,"eq",E,E,2,[[[R[67]],["self"]],["bool"]]],[11,"ne",E,E,2,[[[R[67]],["self"]],["bool"]]],[11,"eq",E,E,1,[[["self"]],["bool"]]],[11,"eq",R[58],E,13,[[["self"]],["bool"]]],[11,"eq",R[59],E,14,[[[R[72]],["self"]],["bool"]]],[11,"ne",E,E,14,[[[R[72]],["self"]],["bool"]]],[11,"eq",R[60],E,15,[[[R[35]],["self"]],["bool"]]],[11,"ne",E,E,15,[[[R[35]],["self"]],["bool"]]],[11,"eq",R[62],E,17,[[[R[18]],["self"]],["bool"]]],[11,"ne",E,E,17,[[[R[18]],["self"]],["bool"]]],[11,"eq",E,E,18,[[[R[69]],["self"]],["bool"]]],[11,"ne",E,E,18,[[[R[69]],["self"]],["bool"]]],[11,"eq",R[14],E,6,[[["self"],[R[7]]],["bool"]]],[11,"ne",E,E,6,[[["self"],[R[7]]],["bool"]]],[11,"eq",E,E,7,[[["self"],["error"]],["bool"]]],[11,"ne",E,E,7,[[["self"],["error"]],["bool"]]],[11,"eq",R[63],E,23,[[["self"],[R[4]]],["bool"]]],[11,"eq",E,E,24,[[[R[73]],["self"]],["bool"]]],[11,"eq",R[14],E,8,[[[R[70]],["self"]],["bool"]]],[11,"ne",E,E,8,[[[R[70]],["self"]],["bool"]]],[11,"partial_cmp",E,E,2,[[[R[67]],["self"]],[[R[74]],[R[6],[R[74]]]]]],[11,"lt",E,E,2,[[[R[67]],["self"]],["bool"]]],[11,"le",E,E,2,[[[R[67]],["self"]],["bool"]]],[11,"gt",E,E,2,[[[R[67]],["self"]],["bool"]]],[11,"ge",E,E,2,[[[R[67]],["self"]],["bool"]]],[11,"fmt",R[60],E,15,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[14],E,7,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",E,E,4,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",E,E,5,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",E,E,2,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",E,E,1,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[58],E,13,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[59],E,14,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[60],E,15,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[62],E,17,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",E,E,18,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[14],E,6,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",E,E,7,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[63],E,23,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",E,E,24,[[["self"],[R[75]]],[R[8]]]],[11,"fmt",R[14],E,8,[[["self"],[R[75]]],[R[8]]]],[11,"hash",E,E,2,[[["self"],["__h"]]]],[11,"hash",R[60],E,15,[[["self"],["__h"]]]],[11,"hash",R[14],E,6,[[["self"],["__h"]]]],[11,"from_iter",R[60],E,16,[[["intoiterator"]],["self"]]]],"p":[[3,"State"],[3,R[76]],[3,R[77]],[3,"Config"],[4,R[78]],[4,R[79]],[4,R[80]],[4,"Error"],[4,R[81]],[3,"Project"],[3,R[82]],[8,"IsCall"],[3,R[83]],[3,R[84]],[3,R[84]],[3,R[85]],[3,R[86]],[4,R[87]],[4,R[88]],[8,"Backend"],[8,R[48]],[8,"BV"],[8,R[84]],[3,R[89]],[3,R[90]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);