var searchIndex={};
searchIndex["haybale"] = {"doc":"For an introduction to the crate and how to get started,…","i":[[3,"Project","haybale","A `Project` is a collection of LLVM code to be explored,…",null,null],[3,"State","","A `State` describes the full program state at a given…",null,null],[12,"solver","","Reference to the solver instance being used",0,null],[12,"config","","The configuration being used",0,null],[12,"cur_loc","","Indicates the instruction which is currently being executed",0,null],[3,"Location","","Fully describes a code location within the LLVM IR.",null,null],[12,"module","","",1,null],[12,"func","","",1,null],[12,"bb","","",1,null],[12,"instr","","",1,null],[12,"source_loc","","Source location which this IR location corresponds to, if…",1,null],[3,"LocationDescription","","Describes a location in LLVM IR in a format more suitable…",null,null],[12,"modname","","",2,null],[12,"funcname","","",2,null],[12,"bbname","","",2,null],[12,"instr","","",2,null],[12,"source_loc","","",2,null],[3,"PathEntry","","Describes one segment of a path through the LLVM IR. The…",null,null],[12,"0","","",3,null],[3,"ExecutionManager","","An `ExecutionManager` allows you to symbolically explore…",null,null],[4,"BBInstrIndex","","Denotes either a particular instruction in a basic block,…",null,null],[13,"Instr","","Index of the instruction within the basic block.…",4,null],[13,"Terminator","","Indicates the basic block terminator (not one of its…",4,null],[4,"ReturnValue","","A simple enum describing the value returned from a function",null,null],[13,"Return","","The function or call returns this value",5,null],[13,"ReturnVoid","","The function or call returns void",5,null],[13,"Throw","","The function or call throws this value (using the LLVM…",5,null],[13,"Abort","","The function or call aborts without ever returning (e.g.,…",5,null],[4,"Error","","Error types used throughout this crate.",null,null],[13,"Unsat","","While performing an operation, we discovered the current…",6,null],[13,"LoopBoundExceeded","","The current path has exceeded the configured `loop_bound`…",6,null],[13,"NullPointerDereference","","The current path has attempted to dereference a null…",6,null],[13,"FunctionNotFound","","Processing a call of a function with the given name, but…",6,null],[13,"SolverError","","The solver returned this processing error while evaluating…",6,null],[13,"UnsupportedInstruction","","Encountered an LLVM instruction which is not currently…",6,null],[13,"MalformedInstruction","","Encountered an LLVM instruction which was malformed, or at…",6,null],[13,"UnreachableInstruction","","Reached an LLVM `Unreachable` instruction",6,null],[13,"FailedToResolveFunctionPointer","","Failed to interpret some symbolic value (`BV`) as a…",6,null],[13,"HookReturnValueMismatch","","The hook for some function returned a value which didn't…",6,null],[13,"OtherError","","Some kind of error which doesn't fall into one of the…",6,null],[4,"SolutionValue","","A simple enum describing either an integer value or a…",null,null],[13,"I8","","",7,null],[13,"I16","","",7,null],[13,"I32","","",7,null],[13,"I64","","",7,null],[13,"Ptr","","",7,null],[5,"symex_function","","Begin symbolic execution of the function named `funcname`,…",null,[[["str"],["project"],["backend"],["config"]],[["executionmanager"],["backend"]]]],[5,"find_zero_of_func","","Given a function, find values of its inputs such that it…",null,[[["str"],["config",["btorbackend"]],["project"],["btorbackend"]],[["result",["option","string"]],["string"],["option",["vec"]]]]],[5,"get_possible_return_values_of_func","","Get a description of the possible return values of a…",null,[[["u32"],["option",["u32"]],["btorbackend"],["str"],["project"],["usize"],["config",["btorbackend"]]],[["returnvalue",["u64"]],["possiblesolutions",["returnvalue"]]]]],[11,"from_bc_path","","Construct a new `Project` from a path to an LLVM bitcode…",8,[[],[["result",["string"]],["string"]]]],[11,"from_bc_paths","","Construct a new `Project` from multiple LLVM bitcode files",8,[[],[["result",["string"]],["string"]]]],[11,"from_bc_dir","","Construct a new `Project` from a path to a directory…",8,[[["str"]],[["error"],["result",["error"]]]]],[11,"from_bc_dir_with_blacklist","","Construct a new `Project` from a path to a directory…",8,[[["str"]],[["error"],["result",["error"]]]]],[11,"add_bc_path","","Add the code in the given LLVM bitcode file to the `Project`",8,[[["self"]],[["result",["string"]],["string"]]]],[11,"add_bc_dir","","Add the code in the given directory to the `Project`. See…",8,[[["self"],["str"]],[["error"],["result",["error"]]]]],[11,"add_bc_dir_with_blacklist","","Add the code in the given directory, except for…",8,[[["str"],["self"]],[["error"],["result",["error"]]]]],[11,"all_functions","","Iterate over all `Function`s in the `Project`. Gives pairs…",8,[[["self"]]]],[11,"all_global_vars","","Iterate over all `GlobalVariable`s in the `Project`. Gives…",8,[[["self"]]]],[11,"all_global_aliases","","Iterate over all `GlobalAlias`es in the `Project`. Gives…",8,[[["self"]]]],[11,"all_named_struct_types","","Iterate over all named struct types in the `Project`.…",8,[[["self"]]]],[11,"active_module_names","","Get the names of the LLVM modules which have been parsed…",8,[[["self"]]]],[11,"get_func_by_name","","Search the project for a function with the given name. If…",8,[[["str"],["self"]],["option"]]],[11,"get_named_struct_type_by_name","","Search the project for a named struct type with the given…",8,[[["str"],["self"]],["option"]]],[11,"get_inner_struct_type_from_named","","Given a `NamedStructType`, get the `StructType`…",8,[[["self"],["type"]],[["option",["arc"]],["arc",["rwlock"]]]]],[11,"state","","Provides access to the `State` resulting from the end of…",9,[[["self"]],["state"]]],[11,"mut_state","","Provides mutable access to the underlying `State` (see…",9,[[["self"]],["state"]]],[11,"param_bvs","","Provides access to the `BV` objects representing each of…",9,[[["self"]],["vec"]]],[0,"layout","","Functions related to the in-memory layout of data types.",null,null],[5,"size","haybale::layout","Get the size of the `Type`, in bits.",null,[[["type"]],["usize"]]],[5,"size_opaque_aware","","Get the size of the `Type`, in bits.",null,[[["project"],["type"]],[["option",["usize"]],["usize"]]]],[5,"fp_size","","Get the size of the `FPType`, in bits",null,[[["fptype"]],["usize"]]],[5,"get_offset_constant_index","","Get the offset (in bytes) of the element at the given…",null,[[["usize"],["type"]],["result"]]],[5,"get_offset_bv_index","","Get the offset (in bytes) of the element at the given…",null,[[["v"],["type"]],["result"]]],[17,"POINTER_SIZE_BITS","","our convention is that pointers are 64 bits",null,null],[0,"config","haybale","The `Config` structure for configuring `haybale`, and…",null,null],[3,"Config","haybale::config","Various settings which affect how the symbolic execution…",null,null],[12,"loop_bound","","Maximum number of times to execute any given line of LLVM…",10,null],[12,"max_callstack_depth","","Maximum callstack depth to allow when symbolically…",10,null],[12,"solver_query_timeout","","Maximum amount of time to allow for any single solver query.",10,null],[12,"null_pointer_checking","","Should we check each memory access for possible `NULL`…",10,null],[12,"concretize_memcpy_lengths","","When encountering a `memcpy`, `memset`, or `memmove` with…",10,null],[12,"max_memcpy_length","","Maximum supported length of a `memcpy`, `memset`, or…",10,null],[12,"squash_unsats","","`Error::Unsat` is an error type which is used internally,…",10,null],[12,"trust_llvm_assumes","","When encountering the `llvm.assume()` intrinsic, should we…",10,null],[12,"function_hooks","","The set of currently active function hooks; see…",10,null],[12,"callbacks","","The set of currently active callbacks; see `Callbacks` for…",10,null],[12,"initial_mem_watchpoints","","The initial memory watchpoints when a `State` is created…",10,null],[12,"demangling","","Controls the (attempted) demangling of function names in…",10,null],[12,"print_source_info","","If `true`, then `haybale` will attempt to print source…",10,null],[12,"print_module_name","","If `true`, then `haybale` will include the module name…",10,null],[4,"Demangling","","Enum used for the `demangling` option in `Config`.",null,null],[13,"NoDemangling","","Don't try to demangle",11,null],[13,"CPP","","Try to demangle using the C++ demangler (suitable for…",11,null],[13,"Rust","","Try to demangle using the Rust demangler (suitable for…",11,null],[4,"NullPointerChecking","","",null,null],[13,"Simple","","All memory accesses will be checked to ensure their…",12,null],[13,"SplitPath","","All memory accesses will be checked to ensure their…",12,null],[13,"None","","Memory accesses will not be checked for `NULL` addresses.…",12,null],[4,"Concretize","","Enum used for the `concretize_memcpy_lengths` option in…",null,null],[13,"Symbolic","","Handle everything fully symbolically - that is, have the…",13,null],[13,"Arbitrary","","Pick one possible value arbitrarily. Often this may choose…",13,null],[13,"Prefer","","Prefer the given `u64` value if it is a possible value.…",13,null],[13,"Maximum","","Choose the maximum possible value. `Maximum` will be…",13,null],[13,"Minimum","","Choose the minimum possible value. `Minimum` will be…",13,null],[11,"new","","Creates a new `Config` with defaults for all the options,…",10,[[],["self"]]],[11,"maybe_demangle","","Attempts to demangle the given function name, as…",11,[[["str"]],["string"]]],[11,"autodetect","","Guesses an appropriate `Demangling` for the given `Project`.",11,[[["project"]],["self"]]],[0,"function_hooks","haybale","Functions and structures for defining and activating…",null,null],[3,"FunctionHooks","haybale::function_hooks","A set of function hooks, which will be executed instead of…",null,null],[5,"generic_stub_hook","","This hook ignores the function arguments and returns an…",null,[[["iscall"],["state"],["project"]],[["result",["returnvalue"]],["returnvalue"]]]],[5,"abort_hook","","This hook ignores the function arguments and returns…",null,[[["iscall"],["state"],["project"]],[["result",["returnvalue"]],["returnvalue"]]]],[6,"Argument","","An `Argument` represents a single argument to a called…",null,null],[8,"IsCall","","`IsCall` exists to unify the commonalities between LLVM…",null,null],[10,"get_called_func","","",14,[[["self"]],["either"]]],[10,"get_arguments","","",14,[[["self"]],["vec"]]],[10,"get_return_attrs","","",14,[[["self"]],["vec"]]],[10,"get_fn_attrs","","",14,[[["self"]],["vec"]]],[10,"get_calling_convention","","",14,[[["self"]],["callingconvention"]]],[11,"new","","Create a blank `FunctionHooks` instance with no function…",15,[[],["self"]]],[11,"add","","Adds a function hook. The `hook` will be executed instead…",15,[[["self"],["h"]]]],[11,"add_cpp_demangled","","Exactly like `add()`, but takes the (C++) demangled name…",15,[[["self"],["h"]]]],[11,"add_rust_demangled","","Exactly like `add()`, but takes the (Rust) demangled name…",15,[[["self"],["h"]]]],[11,"add_inline_asm_hook","","Add a hook to be used for calls to inline assembly. This…",15,[[["self"],["h"]],["bool"]]],[11,"add_default_hook","","Add a hook to be used if no other definition or hook is…",15,[[["self"],["h"]],["bool"]]],[11,"remove","","Removes the function hook for the given function, which…",15,[[["str"],["self"]]]],[11,"remove_cpp_demangled","","Removes the function hook for the given function, which…",15,[[["str"],["self"]]]],[11,"remove_rust_demangled","","Removes the function hook for the given function, which…",15,[[["str"],["self"]]]],[11,"remove_inline_asm_hook","","Removes the function hook used for calls to inline…",15,[[["self"]]]],[11,"remove_default_hook","","Removes the default function hook which was added with…",15,[[["self"]]]],[11,"is_hooked","","Determine whether there is an active hook for the given…",15,[[["str"],["self"]],["bool"]]],[11,"has_inline_asm_hook","","Is there currently an inline asm hook active? (See…",15,[[["self"]],["bool"]]],[11,"has_default_hook","","Is there currently a default hook active? (See…",15,[[["self"]],["bool"]]],[0,"callbacks","haybale","Functions and structures for defining and activating…",null,null],[3,"Callbacks","haybale::callbacks","",null,null],[11,"add_instruction_callback","","Add an instruction callback. `haybale` will call the…",16,[[["self"]]]],[11,"add_terminator_callback","","Add a terminator callback. `haybale` will call the…",16,[[["self"]]]],[0,"alloc_utils","haybale","Utility functions for performing memory allocation. These…",null,null],[5,"malloc","haybale::alloc_utils","Allocate a number of bytes given by the `Operand`.",null,[[["state"],["operand"]],["result"]]],[5,"zalloc","","Allocate a number of bytes given by the `Operand`. The…",null,[[["state"],["operand"]],["result"]]],[5,"calloc","","Allocate a number of bytes given by `a` times `b`, where…",null,[[["state"],["operand"]],["result"]]],[5,"realloc","","Reallocate the given `addr` to be at least the number of…",null,[[["state"],["operand"]],["result"]]],[0,"hook_utils","haybale","Utility functions for performing memset or memcpy…",null,null],[5,"memset","haybale::hook_utils","Set `num_bytes` bytes of memory at address `addr` each to…",null,[[["state"],["operand"]],["result"]]],[5,"memset_bv","","Just like `memset()` above, but takes `BV`s instead of…",null,[[["state"]],["result"]]],[5,"memcpy","","Copies `num_bytes` bytes of memory from address `src` to…",null,[[["state"],["operand"]],["result"]]],[5,"memcpy_bv","","Just like `memcpy()` above, but takes `BV`s instead of…",null,[[["state"]],["result"]]],[11,"to_string_with_module","haybale","Format this `Location` as a string, including the full…",1,[[["self"]],["string"]]],[11,"to_string_no_module","","Format this `Location` as a string, omitting the module name",1,[[["self"]],["string"]]],[11,"to_string_short_module","","Format this `Location` as a string, including the short…",1,[[["self"]],["string"]]],[11,"new","","`start_loc`: the `Location` where the `State` should begin…",0,[[["location"],["project"],["config"]],["self"]]],[11,"fork","","Fully duplicate the `State`. Unlike with `clone()`, the…",0,[[["self"]],["self"]]],[11,"sat","","Returns `true` if current constraints are satisfiable,…",0,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"sat_with_extra_constraints","","Returns `true` if the current constraints plus the given…",0,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"bvs_must_be_equal","","Returns `true` if under the current constraints, `a` and…",0,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"bvs_can_be_equal","","Returns `true` if under the current constraints, `a` and…",0,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"get_a_solution_for_bv","","Get one possible concrete value for the `BV`. Returns…",0,[[["self"]],[["option",["bvsolution"]],["result",["option"]]]]],[11,"get_a_solution_for_irname","","Get one possible concrete value for the given IR `Name`…",0,[[["self"],["string"],["name"]],[["option",["bvsolution"]],["result",["option"]]]]],[11,"get_possible_solutions_for_bv","","Get a description of the possible solutions for the `BV`.",0,[[["usize"],["self"]],[["possiblesolutions",["bvsolution"]],["result",["possiblesolutions"]]]]],[11,"get_possible_solutions_for_irname","","Get a description of the possible solutions for the given…",0,[[["usize"],["name"],["self"],["string"]],[["possiblesolutions",["bvsolution"]],["result",["possiblesolutions"]]]]],[11,"max_possible_solution_for_bv_as_u64","","Get the maximum possible solution for the `BV`: that is,…",0,[[["self"]],[["result",["option"]],["option",["u64"]]]]],[11,"max_possible_solution_for_irname_as_u64","","Get the maximum possible solution for the given IR `Name`…",0,[[["self"],["string"],["name"]],[["result",["option"]],["option",["u64"]]]]],[11,"min_possible_solution_for_bv_as_u64","","Get the minimum possible solution for the `BV`: that is,…",0,[[["self"]],[["result",["option"]],["option",["u64"]]]]],[11,"min_possible_solution_for_irname_as_u64","","Get the minimum possible solution for the given IR `Name`…",0,[[["string"],["self"],["name"]],[["result",["option"]],["option",["u64"]]]]],[11,"bv_from_bool","","Create a `BV` constant representing the given `bool`…",0,[[["self"],["bool"]]]],[11,"bv_from_i32","","Create a `BV` representing the given constant `i32` value,…",0,[[["u32"],["self"],["i32"]]]],[11,"bv_from_u32","","Create a `BV` representing the given constant `u32` value,…",0,[[["u32"],["self"]]]],[11,"bv_from_i64","","Create a `BV` representing the given constant `i64` value,…",0,[[["i64"],["u32"],["self"]]]],[11,"bv_from_u64","","Create a `BV` representing the given constant `u64` value,…",0,[[["u32"],["self"],["u64"]]]],[11,"zero","","Create a `BV` representing the constant `0` of the given…",0,[[["u32"],["self"]]]],[11,"one","","Create a `BV` representing the constant `1` of the given…",0,[[["u32"],["self"]]]],[11,"ones","","Create a `BV` constant of the given width, where all bits…",0,[[["u32"],["self"]]]],[11,"new_bv_with_name","","Create a new (unconstrained) `BV` for the given `Name` (in…",0,[[["self"],["name"],["u32"]],["result"]]],[11,"assign_bv_to_name","","Assign the given `BV` to the given `Name` (in the current…",0,[[["self"],["name"]],["result"]]],[11,"record_bv_result","","Record the result of `thing` to be `resultval`. Assumes…",0,[[["self"]],["result"]]],[11,"overwrite_latest_version_of_bv","","Overwrite the latest version of the given `Name` to…",0,[[["self"],["name"]]]],[11,"operand_to_bv","","Convert an `Operand` to the appropriate `BV`. Assumes the…",0,[[["self"],["operand"]],["result"]]],[11,"const_to_bv","","Convert a `Constant` to the appropriate `BV`.",0,[[["self"],["constant"]],["result"]]],[11,"get_pointer_to_function","","Get a pointer to the given function name. The name must be…",0,[[["self"]],["option"]]],[11,"get_pointer_to_function_hook","","Get a pointer to the currently active hook for the given…",0,[[["str"],["self"]],["option"]]],[11,"get_func_by_name","","Get a `Function` by name. The name must be the…",0,[[["self"]],["option"]]],[11,"read","","Read a value `bits` bits long from memory at `addr`. Note…",0,[[["u32"],["self"]],["result"]]],[11,"write","","Write a value into memory at `addr`. Note that `val` can…",0,[[["self"]],["result"]]],[11,"add_mem_watchpoint","","Add a memory watchpoint. It will be enabled unless/until…",0,[[["watchpoint"],["self"]],["bool"]]],[11,"rm_mem_watchpoint","","Remove the memory watchpoint with the given `name`.",0,[[["str"],["self"]],["bool"]]],[11,"disable_watchpoint","","Disable the memory watchpoint with the given `name`.…",0,[[["str"],["self"]],["bool"]]],[11,"enable_watchpoint","","Enable the memory watchpoint(s) with the given name.",0,[[["str"],["self"]],["bool"]]],[11,"allocate","","Allocate a value of size `bits`; return a pointer to the…",0,[[["self"]]]],[11,"get_allocation_size","","Get the size, in bits, of the allocation at the given…",0,[[["self"]],[["result",["option"]],["option",["u64"]]]]],[11,"record_path_entry","","Record the current location as a `PathEntry` in the…",0,[[["self"]]]],[11,"get_path","","Get the `PathEntry`s that have been recorded, in order",0,[[["self"]],["vec"]]],[11,"push_callsite","","Record entering a normal `Call` at the current location",0,[[["self"],["call"]]]],[11,"push_invokesite","","Record entering the given `Invoke` at the current location",0,[[["invoke"],["self"]]]],[11,"pop_callsite","","Record leaving the current function. Returns the…",0,[[["self"]],[["option",["callsite"]],["callsite"]]]],[11,"current_callstack_depth","","Returns the current callstack depth. `0` indicates we're…",0,[[["self"]],["usize"]]],[11,"save_backtracking_point","","Save the current state, about to enter the `BasicBlock`…",0,[[["self"],["name"]]]],[11,"revert_to_backtracking_point","","returns `Ok(true)` if the operation was successful,…",0,[[["self"]],[["result",["bool"]],["bool"]]]],[11,"count_backtracking_points","","returns the number of saved backtracking points",0,[[["self"]],["usize"]]],[11,"pretty_backtrace","","returns a `String` containing a formatted view of the…",0,[[["self"]],["string"]]],[11,"pretty_path_llvm","","returns a `String` containing a formatted view of the full…",0,[[["self"]],["string"]]],[11,"pretty_path_source","","returns a `String` containing a formatted view of the full…",0,[[["self"]],["string"]]],[11,"pretty_path_interleaved","","returns a `String` containing a formatted view of the full…",0,[[["self"]],["string"]]],[11,"demangle","","Attempt to demangle the given `funcname` as appropriate…",0,[[["str"],["self"]],["string"]]],[11,"all_vars_in_cur_fn","","Get the most recent `BV` created for each `Name` in the…",0,[[["self"]]]],[11,"current_assignments_as_pretty_string","","returns a `String` describing a set of satisfying…",0,[[["self"]],[["string"],["result",["string"]]]]],[11,"full_error_message_with_context","","Returns a `String` describing both the error and the…",0,[[["self"],["error"]],["string"]]],[0,"memory","","Implementation of a `Memory` based on a Boolector array…",null,null],[3,"Memory","haybale::memory","",null,null],[18,"INDEX_BITS","","",17,null],[18,"CELL_BITS","","",17,null],[18,"BITS_IN_BYTE","","",17,null],[18,"LOG_BITS_IN_BYTE","","",17,null],[18,"CELL_BYTES","","",17,null],[18,"LOG_CELL_BYTES","","",17,null],[18,"CELL_OFFSET_MASK","","",17,null],[11,"new_uninitialized","","A new `Memory`, whose contents at all addresses are…",17,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"new_zero_initialized","","A new `Memory`, whose contents at all addresses are…",17,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"get_solver","","Get a reference to the `Btor` instance this `Memory`…",17,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,"change_solver","","Adapt the `Memory` to a new `Btor` instance.",17,[[["self"],["btor"],["rc",["btor"]]]]],[11,"read","","Read any number (>0) of bits of memory, at any alignment.…",17,[[["u32"],["self"],["bv"]],[["result",["bv"]],["bv",["rc"]]]]],[11,"write","","Write any number (>0) of bits of memory, at any alignment.",17,[[["bv",["rc"]],["bv"],["self"],["rc",["btor"]]],["result"]]],[0,"simple_memory","haybale","Simple implementation of a `Memory` based on a Boolector…",null,null],[3,"Memory","haybale::simple_memory","",null,null],[18,"INDEX_BITS","","",18,null],[18,"CELL_BITS","","",18,null],[18,"BITS_IN_BYTE","","",18,null],[18,"LOG_BITS_IN_BYTE","","",18,null],[18,"CELL_BYTES","","",18,null],[11,"new_uninitialized","","A new `Memory`, whose contents at all addresses are…",18,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"new_zero_initialized","","A new `Memory`, whose contents at all addresses are…",18,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"get_solver","","Get a reference to the `Btor` instance this `Memory`…",18,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,"change_solver","","Adapt the `Memory` to a new `Btor` instance.",18,[[["self"],["btor"],["rc",["btor"]]]]],[11,"read","","Read any number (>0) of bits of memory, at any alignment.…",18,[[["u32"],["self"],["bv"]],[["result",["bv"]],["bv",["rc"]]]]],[11,"write","","Write any number (>0) of bits of memory, at any alignment.",18,[[["bv",["rc"]],["bv"],["self"],["rc",["btor"]]],["result"]]],[0,"watchpoints","haybale","Structures for defining and processing memory watchpoints",null,null],[3,"Watchpoint","haybale::watchpoints","A `Watchpoint` describes a segment of memory to watch.",null,null],[3,"Watchpoints","","Stores information about watchpoints and performs…",null,null],[11,"new","","A memory watchpoint for the `bytes` bytes of memory at the…",19,[[["u64"]],["self"]]],[11,"get_lower_bound","","Get the lower bound of the memory segment being watched…",19,[[["self"]],["u64"]]],[11,"get_upper_bound","","Get the upper bound of the memory segment being watched…",19,[[["self"]],["u64"]]],[11,"new","","Construct a new `Watchpoints` instance with no watchpoints.",20,[[],["self"]]],[11,"add","","Add a memory watchpoint. It will be enabled unless/until…",20,[[["watchpoint"],["self"]],["bool"]]],[11,"remove","","Remove the memory watchpoint with the given `name`.",20,[[["str"],["self"]],["bool"]]],[11,"disable","","Disable the memory watchpoint with the given `name`.",20,[[["str"],["self"]],["bool"]]],[11,"enable","","Enable the memory watchpoint(s) with the given name.",20,[[["str"],["self"]],["bool"]]],[0,"solver_utils","haybale","Simple utilities for interacting with the solver",null,null],[4,"PossibleSolutions","haybale::solver_utils","",null,null],[13,"Exactly","","This is exactly the set of possible solutions; there are…",21,null],[13,"AtLeast","","All of the solutions in this set are possible solutions,…",21,null],[4,"SolutionCount","","",null,null],[13,"Exactly","","There are exactly this many solutions",22,null],[13,"AtLeast","","There are at least this many solutions",22,null],[5,"sat","","Returns `true` if current constraints are satisfiable,…",null,[[["btor"]],[["result",["bool"]],["bool"]]]],[5,"sat_with_extra_constraints","","Returns `true` if the current constraints plus the…",null,[[["btor"]],[["result",["bool"]],["bool"]]]],[5,"bvs_must_be_equal","","Returns `true` if under the current constraints, `a` and…",null,[[["v"],["btor"]],[["result",["bool"]],["bool"]]]],[5,"bvs_can_be_equal","","Returns `true` if under the current constraints, `a` and…",null,[[["v"],["btor"]],[["result",["bool"]],["bool"]]]],[5,"get_possible_solutions_for_bv","","Get a description of the possible solutions for the `BV`.",null,[[["v"],["usize"]],[["possiblesolutions",["bvsolution"]],["result",["possiblesolutions"]]]]],[5,"max_possible_solution_for_bv_as_u64","","Get the maximum possible solution for the `BV`: that is,…",null,[[["v"]],[["result",["option"]],["option",["u64"]]]]],[5,"min_possible_solution_for_bv_as_u64","","Get the minimum possible solution for the `BV`: that is,…",null,[[["v"]],[["result",["option"]],["option",["u64"]]]]],[5,"max_possible_solution_for_bv_as_binary_str","","Get the maximum possible solution for the `BV`: that is,…",null,[[["v"]],[["result",["option"]],["option",["string"]]]]],[5,"min_possible_solution_for_bv_as_binary_str","","Get the minimum possible solution for the `BV`: that is,…",null,[[["v"]],[["result",["option"]],["option",["string"]]]]],[11,"as_u64_solutions","","Convert a `PossibleSolutions` over `BVSolution` into a…",21,[[["self"]],[["possiblesolutions",["u64"]],["option",["possiblesolutions"]]]]],[11,"count","","Get a count of how many possible solutions there are.",21,[[["self"]],["solutioncount"]]],[0,"backend","haybale","Traits which abstract over the backend (BV types, memory…",null,null],[3,"BtorBackend","haybale::backend","",null,null],[3,"SimpleMemoryBackend","","",null,null],[8,"Backend","","A `Backend` is just a collection of types which together…",null,null],[16,"SolverRef","","",23,null],[16,"BV","","",23,null],[16,"Memory","","",23,null],[8,"SolverRef","","Trait for something which acts as a reference to a…",null,null],[16,"BV","","",24,null],[16,"Array","","",24,null],[10,"new","","Create a new `Btor` instance, initialize it as necessary,…",24,[[],["self"]]],[10,"duplicate","","As opposed to `clone()` which merely clones the reference,…",24,[[["self"]],["self"]]],[10,"match_bv","","Given a `BV` originally created for any `SolverRef`, get…",24,[[["self"]],["option"]]],[10,"match_array","","Given an `Array` originally created for any `SolverRef`,…",24,[[["self"]],["option"]]],[8,"BV","","Trait for things which can act like bitvectors.",null,null],[16,"SolverRef","","",25,null],[10,"new","","",25,[[["u32"],["str"],["option",["str"]]],["self"]]],[10,"from_bool","","",25,[[["bool"]],["self"]]],[10,"from_i32","","",25,[[["u32"],["i32"]],["self"]]],[10,"from_u32","","",25,[[["u32"]],["self"]]],[10,"from_i64","","",25,[[["i64"],["u32"]],["self"]]],[10,"from_u64","","",25,[[["u32"],["u64"]],["self"]]],[10,"zero","","",25,[[["u32"]],["self"]]],[10,"one","","",25,[[["u32"]],["self"]]],[10,"ones","","",25,[[["u32"]],["self"]]],[10,"from_binary_str","","",25,[[["str"]],["self"]]],[10,"from_dec_str","","",25,[[["str"],["u32"]],["self"]]],[10,"from_hex_str","","",25,[[["str"],["u32"]],["self"]]],[10,"as_binary_str","","",25,[[["self"]],[["string"],["option",["string"]]]]],[10,"as_u64","","",25,[[["self"]],[["u64"],["option",["u64"]]]]],[10,"as_bool","","",25,[[["self"]],[["bool"],["option",["bool"]]]]],[10,"get_a_solution","","",25,[[["self"]],[["result",["bvsolution"]],["bvsolution"]]]],[10,"get_solver","","",25,[[["self"]]]],[10,"get_id","","",25,[[["self"]],["i32"]]],[10,"get_width","","",25,[[["self"]],["u32"]]],[10,"get_symbol","","",25,[[["self"]],[["str"],["option",["str"]]]]],[10,"set_symbol","","",25,[[["str"],["self"],["option",["str"]]]]],[10,"is_const","","",25,[[["self"]],["bool"]]],[10,"has_same_width","","",25,[[["self"]],["bool"]]],[10,"assert","","",25,[[["self"]],["result"]]],[10,"is_failed_assumption","","",25,[[["self"]],["bool"]]],[10,"_eq","","",25,[[["self"]],["self"]]],[10,"_ne","","",25,[[["self"]],["self"]]],[10,"add","","",25,[[["self"]],["self"]]],[10,"sub","","",25,[[["self"]],["self"]]],[10,"mul","","",25,[[["self"]],["self"]]],[10,"udiv","","",25,[[["self"]],["self"]]],[10,"sdiv","","",25,[[["self"]],["self"]]],[10,"urem","","",25,[[["self"]],["self"]]],[10,"srem","","",25,[[["self"]],["self"]]],[10,"smod","","",25,[[["self"]],["self"]]],[10,"inc","","",25,[[["self"]],["self"]]],[10,"dec","","",25,[[["self"]],["self"]]],[10,"neg","","",25,[[["self"]],["self"]]],[10,"uaddo","","",25,[[["self"]],["self"]]],[10,"saddo","","",25,[[["self"]],["self"]]],[10,"usubo","","",25,[[["self"]],["self"]]],[10,"ssubo","","",25,[[["self"]],["self"]]],[10,"umulo","","",25,[[["self"]],["self"]]],[10,"smulo","","",25,[[["self"]],["self"]]],[10,"sdivo","","",25,[[["self"]],["self"]]],[10,"not","","",25,[[["self"]],["self"]]],[10,"and","","",25,[[["self"]],["self"]]],[10,"or","","",25,[[["self"]],["self"]]],[10,"xor","","",25,[[["self"]],["self"]]],[10,"nand","","",25,[[["self"]],["self"]]],[10,"nor","","",25,[[["self"]],["self"]]],[10,"xnor","","",25,[[["self"]],["self"]]],[10,"sll","","",25,[[["self"]],["self"]]],[10,"srl","","",25,[[["self"]],["self"]]],[10,"sra","","",25,[[["self"]],["self"]]],[10,"rol","","",25,[[["self"]],["self"]]],[10,"ror","","",25,[[["self"]],["self"]]],[10,"redand","","",25,[[["self"]],["self"]]],[10,"redor","","",25,[[["self"]],["self"]]],[10,"redxor","","",25,[[["self"]],["self"]]],[10,"ugt","","",25,[[["self"]],["self"]]],[10,"ugte","","",25,[[["self"]],["self"]]],[10,"sgt","","",25,[[["self"]],["self"]]],[10,"sgte","","",25,[[["self"]],["self"]]],[10,"ult","","",25,[[["self"]],["self"]]],[10,"ulte","","",25,[[["self"]],["self"]]],[10,"slt","","",25,[[["self"]],["self"]]],[10,"slte","","",25,[[["self"]],["self"]]],[10,"zext","","",25,[[["u32"],["self"]],["self"]]],[10,"sext","","",25,[[["u32"],["self"]],["self"]]],[10,"slice","","",25,[[["u32"],["self"]],["self"]]],[10,"concat","","",25,[[["self"]],["self"]]],[10,"repeat","","",25,[[["u32"],["self"]],["self"]]],[10,"iff","","",25,[[["self"]],["self"]]],[10,"implies","","",25,[[["self"]],["self"]]],[10,"cond_bv","","",25,[[["self"]],["self"]]],[11,"zero_extend_to_bits","","Zero-extend a `BV` to the specified number of bits. The…",25,[[["u32"],["self"]],["self"]]],[11,"sign_extend_to_bits","","Sign-extend a `BV` to the specified number of bits. The…",25,[[["u32"],["self"]],["self"]]],[11,"uadds","","Saturating addition, unsigned. The result will be the same…",25,[[["self"]],["self"]]],[11,"sadds","","Saturating addition, signed. The result will be the same…",25,[[["self"]],["self"]]],[11,"usubs","","Saturating subtraction, unsigned. The result will be the…",25,[[["self"]],["self"]]],[11,"ssubs","","Saturating subtraction, signed. The result will be the…",25,[[["self"]],["self"]]],[8,"Memory","","Trait for things which can act like 'memories', that is,…",null,null],[16,"SolverRef","","",26,null],[16,"Index","","",26,null],[16,"Value","","",26,null],[10,"new_uninitialized","","A new `Memory`, whose contents at all addresses are…",26,[[["str"],["option",["str"]],["bool"]],["self"]]],[10,"new_zero_initialized","","A new `Memory`, whose contents at all addresses are…",26,[[["str"],["option",["str"]],["bool"]],["self"]]],[10,"read","","Read any number (>0) of bits of memory, at any alignment.…",26,[[["self"],["u32"]],["result"]]],[10,"write","","Write any number (>0) of bits of memory, at any alignment.",26,[[["self"]],["result"]]],[10,"get_solver","","Get a reference to the solver instance this `Memory`…",26,[[["self"]]]],[10,"change_solver","","Adapt the `Memory` to a new solver instance.",26,[[["self"]]]],[6,"Result","haybale","A type alias for convenience, similar to how…",null,null],[11,"unwrap_to_i8","","",7,[[],["i8"]]],[11,"unwrap_to_i16","","",7,[[],["i16"]]],[11,"unwrap_to_i32","","",7,[[],["i32"]]],[11,"unwrap_to_i64","","",7,[[],["i64"]]],[11,"unwrap_to_ptr","","",7,[[],["u64"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,[[["self"],["t"]]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"into_iter","","",9,[[],["i"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"reduce","","",9,[[["f"]],["option"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,[[["self"],["t"]]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,[[["self"],["t"]]]],[11,"to_string","","",6,[[["self"]],["string"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,[[["self"],["t"]]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"from","haybale::config","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,[[["self"],["t"]]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,[[["self"],["t"]]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,[[["self"],["t"]]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"type_id","","",12,[[["self"]],["typeid"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,[[["self"],["t"]]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"from","haybale::function_hooks","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,[[["self"],["t"]]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"from","haybale::callbacks","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,[[["self"],["t"]]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"from","haybale::memory","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,[[["self"],["t"]]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"from","haybale::simple_memory","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,[[["self"],["t"]]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"from","haybale::watchpoints","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,[[["self"],["t"]]]],[11,"to_string","","",19,[[["self"]],["string"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,[[["self"],["t"]]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"from","haybale::solver_utils","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,[[["self"],["t"]]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,[[["self"],["t"]]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"from","haybale::backend","",27,[[["t"]],["t"]]],[11,"into","","",27,[[],["u"]]],[11,"to_owned","","",27,[[["self"]],["t"]]],[11,"clone_into","","",27,[[["self"],["t"]]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"type_id","","",27,[[["self"]],["typeid"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"into","","",28,[[],["u"]]],[11,"to_owned","","",28,[[["self"]],["t"]]],[11,"clone_into","","",28,[[["self"],["t"]]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"try_into","","",28,[[],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"type_id","","",28,[[["self"]],["typeid"]]],[11,"new_uninitialized","haybale::memory","",17,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"new_zero_initialized","","",17,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"read","","",17,[[["self"],["u32"]],["result"]]],[11,"write","","",17,[[["self"]],["result"]]],[11,"get_solver","","",17,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,"change_solver","","",17,[[["self"],["btor"],["rc",["btor"]]]]],[11,"new_uninitialized","haybale::simple_memory","",18,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"new_zero_initialized","","",18,[[["str"],["btor"],["option",["str"]],["rc",["btor"]],["bool"]],["self"]]],[11,"read","","",18,[[["self"],["u32"]],["result"]]],[11,"write","","",18,[[["self"]],["result"]]],[11,"get_solver","","",18,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,"change_solver","","",18,[[["self"],["btor"],["rc",["btor"]]]]],[11,"from","haybale","",2,[[["location"]],["locationdescription"]]],[11,"next","","",9,[[["self"]],["option"]]],[11,"clone","haybale::config","",10,[[["self"]],["config"]]],[11,"clone","","",12,[[["self"]],["nullpointerchecking"]]],[11,"clone","","",13,[[["self"]],["concretize"]]],[11,"clone","","",11,[[["self"]],["demangling"]]],[11,"clone","haybale::function_hooks","",15,[[["self"]],["functionhooks"]]],[11,"clone","haybale::callbacks","",16,[[["self"]],["callbacks"]]],[11,"clone","haybale","",0,[[["self"]],["state"]]],[11,"clone","","",2,[[["self"]],["locationdescription"]]],[11,"clone","","",4,[[["self"]],["bbinstrindex"]]],[11,"clone","","",3,[[["self"]],["pathentry"]]],[11,"clone","","",1,[[["self"]],["location"]]],[11,"clone","haybale::memory","",17,[[["self"]],["memory"]]],[11,"clone","haybale::simple_memory","",18,[[["self"]],["memory"]]],[11,"clone","haybale::watchpoints","",19,[[["self"]],["watchpoint"]]],[11,"clone","","",20,[[["self"]],["watchpoints"]]],[11,"clone","haybale::solver_utils","",21,[[["self"]],["possiblesolutions"]]],[11,"clone","","",22,[[["self"]],["solutioncount"]]],[11,"clone","haybale","",5,[[["self"]],["returnvalue"]]],[11,"clone","","",6,[[["self"]],["error"]]],[11,"clone","haybale::backend","",27,[[["self"]],["btorbackend"]]],[11,"clone","","",28,[[["self"]],["simplememorybackend"]]],[11,"clone","haybale","",7,[[["self"]],["solutionvalue"]]],[11,"default","haybale::config","Default values for all configuration parameters.",10,[[],["self"]]],[11,"default","haybale::function_hooks","Provides predefined hooks for common functions. (At the…",15,[[],["self"]]],[11,"default","haybale::callbacks","",16,[[],["self"]]],[11,"default","haybale::watchpoints","",20,[[],["watchpoints"]]],[11,"cmp","haybale","",2,[[["self"],["locationdescription"]],["ordering"]]],[11,"cmp","","",4,[[["bbinstrindex"],["self"]],["ordering"]]],[11,"eq","haybale::config","",12,[[["nullpointerchecking"],["self"]],["bool"]]],[11,"eq","","",13,[[["self"],["concretize"]],["bool"]]],[11,"ne","","",13,[[["self"],["concretize"]],["bool"]]],[11,"eq","","",11,[[["demangling"],["self"]],["bool"]]],[11,"eq","haybale","",2,[[["self"],["locationdescription"]],["bool"]]],[11,"ne","","",2,[[["self"],["locationdescription"]],["bool"]]],[11,"eq","","",4,[[["bbinstrindex"],["self"]],["bool"]]],[11,"ne","","",4,[[["bbinstrindex"],["self"]],["bool"]]],[11,"eq","","",3,[[["pathentry"],["self"]],["bool"]]],[11,"ne","","",3,[[["pathentry"],["self"]],["bool"]]],[11,"eq","","",1,[[["self"]],["bool"]]],[11,"eq","haybale::memory","",17,[[["self"]],["bool"]]],[11,"eq","haybale::simple_memory","",18,[[["self"],["memory"]],["bool"]]],[11,"ne","","",18,[[["self"],["memory"]],["bool"]]],[11,"eq","haybale::watchpoints","",19,[[["self"],["watchpoint"]],["bool"]]],[11,"ne","","",19,[[["self"],["watchpoint"]],["bool"]]],[11,"eq","haybale::solver_utils","",21,[[["self"],["possiblesolutions"]],["bool"]]],[11,"ne","","",21,[[["self"],["possiblesolutions"]],["bool"]]],[11,"eq","","",22,[[["solutioncount"],["self"]],["bool"]]],[11,"ne","","",22,[[["solutioncount"],["self"]],["bool"]]],[11,"eq","haybale","",5,[[["returnvalue"],["self"]],["bool"]]],[11,"ne","","",5,[[["returnvalue"],["self"]],["bool"]]],[11,"eq","","",6,[[["error"],["self"]],["bool"]]],[11,"ne","","",6,[[["error"],["self"]],["bool"]]],[11,"eq","haybale::backend","",27,[[["btorbackend"],["self"]],["bool"]]],[11,"eq","","",28,[[["simplememorybackend"],["self"]],["bool"]]],[11,"eq","haybale","",7,[[["solutionvalue"],["self"]],["bool"]]],[11,"ne","","",7,[[["solutionvalue"],["self"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["locationdescription"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",2,[[["self"],["locationdescription"]],["bool"]]],[11,"le","","",2,[[["self"],["locationdescription"]],["bool"]]],[11,"gt","","",2,[[["self"],["locationdescription"]],["bool"]]],[11,"ge","","",2,[[["self"],["locationdescription"]],["bool"]]],[11,"partial_cmp","","",4,[[["bbinstrindex"],["self"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",4,[[["bbinstrindex"],["self"]],["bool"]]],[11,"le","","",4,[[["bbinstrindex"],["self"]],["bool"]]],[11,"gt","","",4,[[["bbinstrindex"],["self"]],["bool"]]],[11,"ge","","",4,[[["bbinstrindex"],["self"]],["bool"]]],[11,"fmt","haybale::config","",12,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",13,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale::memory","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale::simple_memory","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale::watchpoints","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale::solver_utils","",21,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",22,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",6,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale::backend","",27,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",28,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale::watchpoints","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","haybale","",6,[[["formatter"],["self"]],["result"]]],[11,"hash","","",2,[[["self"],["__h"]]]],[11,"hash","","",4,[[["self"],["__h"]]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"hash","haybale::watchpoints","",19,[[["self"],["__h"]]]],[11,"hash","haybale","",5,[[["self"],["__h"]]]],[11,"from_iter","haybale::watchpoints","",20,[[["intoiterator"]],["self"]]]],"p":[[3,"State"],[3,"Location"],[3,"LocationDescription"],[3,"PathEntry"],[4,"BBInstrIndex"],[4,"ReturnValue"],[4,"Error"],[4,"SolutionValue"],[3,"Project"],[3,"ExecutionManager"],[3,"Config"],[4,"Demangling"],[4,"NullPointerChecking"],[4,"Concretize"],[8,"IsCall"],[3,"FunctionHooks"],[3,"Callbacks"],[3,"Memory"],[3,"Memory"],[3,"Watchpoint"],[3,"Watchpoints"],[4,"PossibleSolutions"],[4,"SolutionCount"],[8,"Backend"],[8,"SolverRef"],[8,"BV"],[8,"Memory"],[3,"BtorBackend"],[3,"SimpleMemoryBackend"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);