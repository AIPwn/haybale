var N=null,E="",T="t",U="u",searchIndex={};
var R=["source_loc","config","backend","btorbackend","project","option","string","returnvalue","result","Construct a new `Project` from a path to a directory…","Get the size of the `Type`, in bits.","Get the offset (in bytes) of the element at the given…","duration","function_hooks","haybale","Removes the function hook for the given function, which…","operand","Returns `true` if under the current constraints, `a` and…","bvsolution","possiblesolutions","get_func_by_name","callsite","returns a `String` containing a formatted view of the full…","A new `Memory`, whose contents at all addresses are…","INDEX_BITS","CELL_BITS","BITS_IN_BYTE","LOG_BITS_IN_BYTE","CELL_BYTES","new_uninitialized","new_zero_initialized","get_solver","Get a reference to the `Btor` instance this `Memory`…","change_solver","Adapt the `Memory` to a new `Btor` instance.","Read any number (>0) of bits of memory, at any alignment.…","Write any number (>0) of bits of memory, at any alignment.","Add a memory watchpoint. It will be enabled unless/until…","watchpoint","Remove the memory watchpoint with the given `name`.","Enable the memory watchpoint(s) with the given name.","Returns `true` if current constraints are satisfiable,…","sat_with_extra_constraints","bvs_must_be_equal","bvs_can_be_equal","get_possible_solutions_for_bv","Get a description of the possible solutions for the `BV`.","max_possible_solution_for_bv_as_u64","Get the maximum possible solution for the `BV`: that is,…","min_possible_solution_for_bv_as_u64","Get the minimum possible solution for the `BV`: that is,…","SolverRef","try_from","try_into","borrow_mut","to_owned","clone_into","type_id","borrow","typeid","to_string","haybale::config","haybale::function_hooks","haybale::memory","haybale::simple_memory","haybale::watchpoints","haybale::solver_utils","haybale::backend","location","concretize","demangling","locationdescription","watchpoints","solutioncount","default","bbinstrindex","ordering","pathentry","memory","simplememorybackend","solutionvalue","partial_cmp","formatter","Location","LocationDescription","PathEntry","BBInstrIndex","ReturnValue","SolutionValue","ExecutionManager","Demangling","Concretize","FunctionHooks","Memory","Watchpoint","Watchpoints","PossibleSolutions","SolutionCount","BtorBackend","SimpleMemoryBackend"];

searchIndex["haybale"]={"doc":"For an introduction to the crate and how to get started,…","i":[[3,"Project",R[14],"A `Project` is a collection of LLVM code to be explored,…",N,N],[3,"State",E,"A `State` describes the full program state at a given…",N,N],[12,"solver",E,"Reference to the solver instance being used",0,N],[12,R[1],E,"The configuration being used",0,N],[12,"cur_loc",E,"Indicates the instruction which is currently being executed",0,N],[3,R[83],E,"Fully describes a code location within the LLVM IR.",N,N],[12,"module",E,E,1,N],[12,"func",E,E,1,N],[12,"bb",E,E,1,N],[12,"instr",E,E,1,N],[12,R[0],E,"Source location which this IR location corresponds to, if…",1,N],[3,R[84],E,"Describes a location in LLVM IR in a format more suitable…",N,N],[12,"modname",E,E,2,N],[12,"funcname",E,E,2,N],[12,"bbname",E,E,2,N],[12,"instr",E,E,2,N],[12,R[0],E,E,2,N],[3,R[85],E,"Describes one segment of a path through the LLVM IR. The…",N,N],[12,"0",E,E,3,N],[3,R[89],E,"An `ExecutionManager` allows you to symbolically explore…",N,N],[4,R[86],E,"Denotes either a particular instruction in a basic block,…",N,N],[13,"Instr",E,"Index of the instruction within the basic block.…",4,N],[13,"Terminator",E,"Indicates the basic block terminator (not one of its…",4,N],[4,R[87],E,"A simple enum describing the value returned from a function",N,N],[13,"Return",E,"The function or call returns this value",5,N],[13,"ReturnVoid",E,"The function or call returns void",5,N],[13,"Throw",E,"The function or call throws this value (using the LLVM…",5,N],[13,"Abort",E,"The function or call aborts without ever returning (e.g.,…",5,N],[4,"Error",E,"Error types used throughout this crate.",N,N],[13,"Unsat",E,"While performing an operation, we discovered the current…",6,N],[13,"LoopBoundExceeded",E,"The current path has exceeded the configured `loop_bound`…",6,N],[13,"NullPointerDereference",E,"The current path has attempted to dereference a null…",6,N],[13,"FunctionNotFound",E,"Processing a call of a function with the given name, but…",6,N],[13,"SolverError",E,"The solver returned this processing error while evaluating…",6,N],[13,"UnsupportedInstruction",E,"Encountered an LLVM instruction which is not currently…",6,N],[13,"MalformedInstruction",E,"Encountered an LLVM instruction which was malformed, or at…",6,N],[13,"OtherError",E,"Some kind of error which doesn't fall into one of the…",6,N],[4,R[88],E,"A simple enum describing either an integer value or a…",N,N],[13,"I8",E,E,7,N],[13,"I16",E,E,7,N],[13,"I32",E,E,7,N],[13,"I64",E,E,7,N],[13,"Ptr",E,E,7,N],[5,"symex_function",E,"Begin symbolic execution of the function named `funcname`,…",N,[[["str"],[R[1]],[R[2]],[R[4]]],[["executionmanager"],[R[2]]]]],[5,"find_zero_of_func",E,"Given a function, find values of its inputs such that it…",N,[[["str"],[R[3]],[R[1],[R[3]]],[R[4]]],[[R[8],[R[5],R[6]]],[R[5],["vec"]],[R[6]]]]],[5,"get_possible_return_values_of_func",E,"Get a description of the possible return values of a…",N,[[[R[5],["u32"]],["u32"],[R[4]],[R[1],[R[3]]],["str"],["usize"],[R[3]]],[[R[19],[R[7]]],[R[7],["u64"]]]]],[11,"from_bc_path",E,"Construct a new `Project` from a path to an LLVM bitcode…",8,[[],[[R[8],[R[6]]],[R[6]]]]],[11,"from_bc_paths",E,"Construct a new `Project` from multiple LLVM bitcode files",8,[[],[[R[8],[R[6]]],[R[6]]]]],[11,"from_bc_dir",E,R[9],8,[[["str"]],[[R[8],["error"]],["error"]]]],[11,"from_bc_dir_with_blacklist",E,R[9],8,[[["str"]],[[R[8],["error"]],["error"]]]],[11,"add_bc_path",E,"Add the code in the given LLVM bitcode file to the `Project`",8,[[["self"]],[[R[8],[R[6]]],[R[6]]]]],[11,"add_bc_dir",E,"Add the code in the given directory to the `Project`. See…",8,[[["str"],["self"]],[[R[8],["error"]],["error"]]]],[11,"add_bc_dir_with_blacklist",E,"Add the code in the given directory, except for…",8,[[["str"],["self"]],[[R[8],["error"]],["error"]]]],[11,"all_functions",E,"Iterate over all `Function`s in the `Project`. Gives pairs…",8,[[["self"]]]],[11,"all_global_vars",E,"Iterate over all `GlobalVariable`s in the `Project`. Gives…",8,[[["self"]]]],[11,"all_global_aliases",E,"Iterate over all `GlobalAlias`es in the `Project`. Gives…",8,[[["self"]]]],[11,"all_named_struct_types",E,"Iterate over all named struct types in the `Project`.…",8,[[["self"]]]],[11,"active_module_names",E,"Get the names of the LLVM modules which have been parsed…",8,[[["self"]]]],[11,R[20],E,"Search the project for a function with the given name. If…",8,[[["str"],["self"]],[R[5]]]],[11,"get_named_struct_type_by_name",E,"Search the project for a named struct type with the given…",8,[[["str"],["self"]],[R[5]]]],[11,"get_inner_struct_type_from_named",E,"Given a `NamedStructType`, get the `StructType`…",8,[[["self"],["type"]],[["arc",["rwlock"]],[R[5],["arc"]]]]],[11,"state",E,"Provides access to the `State` resulting from the end of…",9,[[["self"]],["state"]]],[11,"mut_state",E,"Provides mutable access to the underlying `State` (see…",9,[[["self"]],["state"]]],[11,"param_bvs",E,"Provides access to the `BV` objects representing each of…",9,[[["self"]],["vec"]]],[0,"layout",E,"Functions related to the in-memory layout of data types.",N,N],[5,"size","haybale::layout",R[10],N,[[["type"]],["usize"]]],[5,"size_opaque_aware",E,R[10],N,[[[R[4]],["type"]],["usize"]]],[5,"fp_size",E,"Get the size of the `FPType`, in bits",N,[[["fptype"]],["usize"]]],[5,"get_offset_constant_index",E,R[11],N,[[["usize"],["type"]],[R[8]]]],[5,"get_offset_bv_index",E,R[11],N,[[["type"],["v"]],[R[8]]]],[17,"POINTER_SIZE_BITS",E,"our convention is that pointers are 64 bits",N,N],[0,R[1],R[14],"The `Config` structure for configuring `haybale`, and…",N,N],[3,"Config",R[61],"Various settings which affect how the symbolic execution…",N,N],[12,"loop_bound",E,"Maximum number of times to execute any given line of LLVM…",10,N],[12,"solver_query_timeout",E,"Maximum amount of time to allow for any single solver query.",10,N],[12,"null_detection",E,"If `true`, all memory accesses will be checked to ensure…",10,N],[12,"concretize_memcpy_lengths",E,"When encountering a `memcpy`, `memset`, or `memmove` with…",10,N],[12,"squash_unsats",E,"`Error::Unsat` is an error type which is used internally,…",10,N],[12,"trust_llvm_assumes",E,"When encountering the `llvm.assume()` intrinsic, should we…",10,N],[12,R[13],E,"The set of currently active function hooks; see…",10,N],[12,"initial_mem_watchpoints",E,"The initial memory watchpoints when a `State` is created…",10,N],[12,R[70],E,"Controls the (attempted) demangling of function names in…",10,N],[12,"print_source_info",E,"If `true`, then `haybale` will attempt to print source…",10,N],[12,"print_module_name",E,"If `true`, then `haybale` will include the module name…",10,N],[4,R[90],E,E,N,N],[13,"NoDemangling",E,"Don't try to demangle",11,N],[13,"CPP",E,"Try to demangle using the C++ demangler (suitable for…",11,N],[13,"Rust",E,"Try to demangle using the Rust demangler (suitable for…",11,N],[4,R[91],E,E,N,N],[13,"Symbolic",E,"Handle everything fully symbolically - that is, have the…",12,N],[13,"Arbitrary",E,"Pick one possible value arbitrarily. Often this may choose…",12,N],[13,"Prefer",E,"Prefer the given `u64` value if it is a possible value.…",12,N],[13,"Maximum",E,"Choose the maximum possible value. `Maximum` will be…",12,N],[13,"Minimum",E,"Choose the minimum possible value. `Minimum` will be…",12,N],[11,"new",E,"Creates a new `Config` with the given `loop_bound`,…",10,[[[R[69]],["usize"],[R[5],[R[12]]],[R[12]],["bool"]],["self"]]],[11,"maybe_demangle",E,"Attempts to demangle the given function name, as…",11,[[["str"]],[R[6]]]],[11,"autodetect",E,"Guesses an appropriate `Demangling` for the given `Project`.",11,[[[R[4]]],["self"]]],[0,R[13],R[14],"Functions and structures for defining and activating…",N,N],[3,R[92],R[62],"A set of function hooks, which will be executed instead of…",N,N],[5,"generic_stub_hook",E,"This hook ignores the function arguments and returns an…",N,[[[R[4]],["state"],["iscall"]],[[R[7]],[R[8],[R[7]]]]]],[5,"abort_hook",E,"This hook ignores the function arguments and returns…",N,[[[R[4]],["state"],["iscall"]],[[R[7]],[R[8],[R[7]]]]]],[6,"Argument",E,"An `Argument` represents a single argument to a called…",N,N],[8,"IsCall",E,"`IsCall` exists to unify the commonalities between LLVM…",N,N],[10,"get_called_func",E,E,13,[[["self"]],["either"]]],[10,"get_arguments",E,E,13,[[["self"]],["vec"]]],[10,"get_return_attrs",E,E,13,[[["self"]],["vec"]]],[10,"get_fn_attrs",E,E,13,[[["self"]],["vec"]]],[10,"get_calling_convention",E,E,13,[[["self"]],["callingconvention"]]],[11,"new",E,"Create a blank `FunctionHooks` instance with no function…",14,[[],["self"]]],[11,"add",E,"Adds a function hook. The `hook` will be executed instead…",14,[[["self"],["h"]]]],[11,"add_cpp_demangled",E,"Exactly like `add()`, but takes the (C++) demangled name…",14,[[["self"],["h"]]]],[11,"add_rust_demangled",E,"Exactly like `add()`, but takes the (Rust) demangled name…",14,[[["self"],["h"]]]],[11,"add_inline_asm_hook",E,"Add a hook to be used for calls to inline assembly. This…",14,[[["self"],["h"]],["bool"]]],[11,"remove",E,R[15],14,[[["str"],["self"]]]],[11,"remove_cpp_demangled",E,R[15],14,[[["str"],["self"]]]],[11,"remove_rust_demangled",E,R[15],14,[[["str"],["self"]]]],[11,"remove_inline_asm_hook",E,"Removes the function hook used for calls to inline…",14,[[["self"]]]],[11,"is_hooked",E,"Determine whether there is an active hook for the given…",14,[[["str"],["self"]],["bool"]]],[0,"alloc_utils",R[14],"Utility functions for performing memory allocation. These…",N,N],[5,"malloc","haybale::alloc_utils","Allocate a number of bytes given by the `Operand`.",N,[[["state"],[R[16]]],[R[8]]]],[5,"zalloc",E,"Allocate a number of bytes given by the `Operand`. The…",N,[[["state"],[R[16]]],[R[8]]]],[5,"calloc",E,"Allocate a number of bytes given by `a` times `b`, where…",N,[[["state"],[R[16]]],[R[8]]]],[5,"realloc",E,"Reallocate the given `addr` to be at least the number of…",N,[[["state"],[R[16]]],[R[8]]]],[0,"hook_utils",R[14],"Utility functions for performing memset or memcpy…",N,N],[5,"memset","haybale::hook_utils","Set `num_bytes` bytes of memory at address `addr` each to…",N,[[["state"],[R[16]]],[R[8]]]],[5,"memcpy",E,"Copies `num_bytes` bytes of memory from address `src` to…",N,[[["state"],[R[16]]],[R[8]]]],[11,"new",R[14],"`start_loc`: the `Location` where the `State` should begin…",0,[[[R[68]],[R[1]],[R[4]]],["self"]]],[11,"fork",E,"Fully duplicate the `State`. Unlike with `clone()`, the…",0,[[["self"]],["self"]]],[11,"sat",E,R[41],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[42],E,"Returns `true` if the current constraints plus the given…",0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[43],E,R[17],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[44],E,R[17],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,"get_a_solution_for_bv",E,"Get one possible concrete value for the `BV`. Returns…",0,[[["self"]],[[R[5],[R[18]]],[R[8],[R[5]]]]]],[11,"get_a_solution_for_irname",E,"Get one possible concrete value for the given IR `Name`…",0,[[["self"],[R[6]],["name"]],[[R[5],[R[18]]],[R[8],[R[5]]]]]],[11,R[45],E,R[46],0,[[["self"],["usize"]],[[R[19],[R[18]]],[R[8],[R[19]]]]]],[11,"get_possible_solutions_for_irname",E,"Get a description of the possible solutions for the given…",0,[[[R[6]],["usize"],["name"],["self"]],[[R[19],[R[18]]],[R[8],[R[19]]]]]],[11,R[47],E,R[48],0,[[["self"]],[[R[8],[R[5]]],[R[5],["u64"]]]]],[11,"max_possible_solution_for_irname_as_u64",E,"Get the maximum possible solution for the given IR `Name`…",0,[[["self"],[R[6]],["name"]],[[R[8],[R[5]]],[R[5],["u64"]]]]],[11,R[49],E,R[50],0,[[["self"]],[[R[8],[R[5]]],[R[5],["u64"]]]]],[11,"min_possible_solution_for_irname_as_u64",E,"Get the minimum possible solution for the given IR `Name`…",0,[[[R[6]],["self"],["name"]],[[R[8],[R[5]]],[R[5],["u64"]]]]],[11,"bv_from_bool",E,"Create a `BV` constant representing the given `bool`…",0,[[["self"],["bool"]]]],[11,"bv_from_i32",E,"Create a `BV` representing the given constant `i32` value,…",0,[[["u32"],["self"],["i32"]]]],[11,"bv_from_u32",E,"Create a `BV` representing the given constant `u32` value,…",0,[[["u32"],["self"]]]],[11,"bv_from_i64",E,"Create a `BV` representing the given constant `i64` value,…",0,[[["i64"],["u32"],["self"]]]],[11,"bv_from_u64",E,"Create a `BV` representing the given constant `u64` value,…",0,[[["u32"],["self"],["u64"]]]],[11,"zero",E,"Create a `BV` representing the constant `0` of the given…",0,[[["u32"],["self"]]]],[11,"one",E,"Create a `BV` representing the constant `1` of the given…",0,[[["u32"],["self"]]]],[11,"ones",E,"Create a `BV` constant of the given width, where all bits…",0,[[["u32"],["self"]]]],[11,"new_bv_with_name",E,"Create a new (unconstrained) `BV` for the given `Name` (in…",0,[[["self"],["name"],["u32"]],[R[8]]]],[11,"assign_bv_to_name",E,"Assign the given `BV` to the given `Name` (in the current…",0,[[["self"],["name"]],[R[8]]]],[11,"record_bv_result",E,"Record the result of `thing` to be `resultval`. Assumes…",0,[[["self"]],[R[8]]]],[11,"overwrite_latest_version_of_bv",E,"Overwrite the latest version of the given `Name` to…",0,[[["self"],["name"]]]],[11,"operand_to_bv",E,"Convert an `Operand` to the appropriate `BV`. Assumes the…",0,[[[R[16]],["self"]],[R[8]]]],[11,"const_to_bv",E,"Convert a `Constant` to the appropriate `BV`.",0,[[["self"],["constant"]],[R[8]]]],[11,"get_pointer_to_function",E,"Get a pointer to the given function name. The name must be…",0,[[["self"]],[R[5]]]],[11,"get_pointer_to_function_hook",E,"Get a pointer to the currently active hook for the given…",0,[[["str"],["self"]],[R[5]]]],[11,R[20],E,"Get a `Function` by name. The name must be the…",0,[[["self"]],[R[5]]]],[11,"read",E,"Read a value `bits` bits long from memory at `addr`. Note…",0,[[["self"],["u32"]],[R[8]]]],[11,"write",E,"Write a value into memory at `addr`. Note that `val` can…",0,[[["self"]],[R[8]]]],[11,"add_mem_watchpoint",E,R[37],0,[[["self"],[R[38]]],["bool"]]],[11,"rm_mem_watchpoint",E,R[39],0,[[["str"],["self"]],["bool"]]],[11,"disable_watchpoint",E,"Disable the memory watchpoint with the given `name`.…",0,[[["str"],["self"]],["bool"]]],[11,"enable_watchpoint",E,R[40],0,[[["str"],["self"]],["bool"]]],[11,"allocate",E,"Allocate a value of size `bits`; return a pointer to the…",0,[[["self"]]]],[11,"get_allocation_size",E,"Get the size, in bits, of the allocation at the given…",0,[[["self"]],[[R[8],[R[5]]],[R[5],["u64"]]]]],[11,"record_path_entry",E,"Record the current location as a `PathEntry` in the…",0,[[["self"]]]],[11,"get_path",E,"Get the `PathEntry`s that have been recorded, in order",0,[[["self"]],["vec"]]],[11,"push_callsite",E,"Record entering a normal `Call` at the current location",0,[[["call"],["self"]]]],[11,"push_invokesite",E,"Record entering the given `Invoke` at the current location",0,[[["self"],["invoke"]]]],[11,"pop_callsite",E,"Record leaving the current function. Returns the…",0,[[["self"]],[[R[21]],[R[5],[R[21]]]]]],[11,"save_backtracking_point",E,"Save the current state, about to enter the `BasicBlock`…",0,[[["self"],["name"]]]],[11,"revert_to_backtracking_point",E,"returns `Ok(true)` if the operation was successful,…",0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,"count_backtracking_points",E,"returns the number of saved backtracking points",0,[[["self"]],["usize"]]],[11,"pretty_backtrace",E,"returns a `String` containing a formatted view of the…",0,[[["self"]],[R[6]]]],[11,"pretty_path_llvm",E,R[22],0,[[["self"]],[R[6]]]],[11,"pretty_path_source",E,R[22],0,[[["self"]],[R[6]]]],[11,"pretty_path_interleaved",E,R[22],0,[[["self"]],[R[6]]]],[11,"demangle",E,"Attempt to demangle the given `funcname` as appropriate…",0,[[["str"],["self"]],[R[6]]]],[11,"all_vars_in_cur_fn",E,"Get the most recent `BV` created for each `Name` in the…",0,[[["self"]]]],[11,"current_assignments_as_pretty_string",E,"returns a `String` describing a set of satisfying…",0,[[["self"]],[[R[8],[R[6]]],[R[6]]]]],[11,"full_error_message_with_context",E,"Returns a `String` describing both the error and the…",0,[[["error"],["self"]],[R[6]]]],[0,R[78],E,"Implementation of a `Memory` based on a Boolector array…",N,N],[3,R[93],R[63],E,N,N],[18,R[24],E,E,15,N],[18,R[25],E,E,15,N],[18,R[26],E,E,15,N],[18,R[27],E,E,15,N],[18,R[28],E,E,15,N],[18,"LOG_CELL_BYTES",E,E,15,N],[18,"CELL_OFFSET_MASK",E,E,15,N],[11,R[29],E,R[23],15,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,R[30],E,R[23],15,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,R[31],E,R[32],15,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[33],E,R[34],15,[[["self"],["btor"],["rc",["btor"]]]]],[11,"read",E,R[35],15,[[["u32"],["self"],["bv"]],[[R[8],["bv"]],["bv",["rc"]]]]],[11,"write",E,R[36],15,[[["rc",["btor"]],["self"],["bv",["rc"]],["bv"]],[R[8]]]],[0,"simple_memory",R[14],"Simple implementation of a `Memory` based on a Boolector…",N,N],[3,R[93],R[64],E,N,N],[18,R[24],E,E,16,N],[18,R[25],E,E,16,N],[18,R[26],E,E,16,N],[18,R[27],E,E,16,N],[18,R[28],E,E,16,N],[11,R[29],E,R[23],16,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,R[30],E,R[23],16,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,R[31],E,R[32],16,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[33],E,R[34],16,[[["self"],["btor"],["rc",["btor"]]]]],[11,"read",E,R[35],16,[[["u32"],["self"],["bv"]],[[R[8],["bv"]],["bv",["rc"]]]]],[11,"write",E,R[36],16,[[["rc",["btor"]],["self"],["bv",["rc"]],["bv"]],[R[8]]]],[0,R[72],R[14],"Structures for defining and processing memory watchpoints",N,N],[3,R[94],R[65],"A `Watchpoint` describes a segment of memory to watch.",N,N],[3,R[95],E,"Stores information about watchpoints and performs…",N,N],[11,"new",E,"A memory watchpoint for the `bytes` bytes of memory at the…",17,[[["u64"]],["self"]]],[11,"new",E,"Construct a new `Watchpoints` instance with no watchpoints.",18,[[],["self"]]],[11,"add",E,R[37],18,[[["self"],[R[38]]],["bool"]]],[11,"remove",E,R[39],18,[[["str"],["self"]],["bool"]]],[11,"disable",E,"Disable the memory watchpoint with the given `name`.",18,[[["str"],["self"]],["bool"]]],[11,"enable",E,R[40],18,[[["str"],["self"]],["bool"]]],[0,"solver_utils",R[14],"Simple utilities for interacting with the solver",N,N],[4,R[96],R[66],E,N,N],[13,"Exactly",E,"This is exactly the set of possible solutions; there are…",19,N],[13,"AtLeast",E,"All of the solutions in this set are possible solutions,…",19,N],[4,R[97],E,E,N,N],[13,"Exactly",E,"There are exactly this many solutions",20,N],[13,"AtLeast",E,"There are at least this many solutions",20,N],[5,"sat",E,R[41],N,[[["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[42],E,"Returns `true` if the current constraints plus the…",N,[[["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[43],E,R[17],N,[[["v"],["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[44],E,R[17],N,[[["v"],["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[45],E,R[46],N,[[["v"],["usize"]],[[R[19],[R[18]]],[R[8],[R[19]]]]]],[5,R[47],E,R[48],N,[[["v"]],[[R[8],[R[5]]],[R[5],["u64"]]]]],[5,R[49],E,R[50],N,[[["v"]],[[R[8],[R[5]]],[R[5],["u64"]]]]],[5,"max_possible_solution_for_bv_as_binary_str",E,R[48],N,[[["v"]],[[R[5],[R[6]]],[R[8],[R[5]]]]]],[5,"min_possible_solution_for_bv_as_binary_str",E,R[50],N,[[["v"]],[[R[5],[R[6]]],[R[8],[R[5]]]]]],[11,"as_u64_solutions",E,"Convert a `PossibleSolutions` over `BVSolution` into a…",19,[[["self"]],[[R[5],[R[19]]],[R[19],["u64"]]]]],[11,"count",E,"Get a count of how many possible solutions there are.",19,[[["self"]],[R[73]]]],[0,R[2],R[14],"Traits which abstract over the backend (BV types, memory…",N,N],[3,R[98],R[67],E,N,N],[3,R[99],E,E,N,N],[8,"Backend",E,"A `Backend` is just a collection of types which together…",N,N],[16,R[51],E,E,21,N],[16,"BV",E,E,21,N],[16,R[93],E,E,21,N],[8,R[51],E,"Trait for something which acts as a reference to a…",N,N],[16,"BV",E,E,22,N],[16,"Array",E,E,22,N],[10,"new",E,"Create a new `Btor` instance, initialize it as necessary,…",22,[[],["self"]]],[10,"duplicate",E,"As opposed to `clone()` which merely clones the reference,…",22,[[["self"]],["self"]]],[10,"match_bv",E,"Given a `BV` originally created for any `SolverRef`, get…",22,[[["self"]],[R[5]]]],[10,"match_array",E,"Given an `Array` originally created for any `SolverRef`,…",22,[[["self"]],[R[5]]]],[8,"BV",E,"Trait for things which can act like bitvectors.",N,N],[16,R[51],E,E,23,N],[10,"new",E,E,23,[[["str"],["u32"],[R[5],["str"]]],["self"]]],[10,"from_bool",E,E,23,[[["bool"]],["self"]]],[10,"from_i32",E,E,23,[[["u32"],["i32"]],["self"]]],[10,"from_u32",E,E,23,[[["u32"]],["self"]]],[10,"from_i64",E,E,23,[[["i64"],["u32"]],["self"]]],[10,"from_u64",E,E,23,[[["u32"],["u64"]],["self"]]],[10,"zero",E,E,23,[[["u32"]],["self"]]],[10,"one",E,E,23,[[["u32"]],["self"]]],[10,"ones",E,E,23,[[["u32"]],["self"]]],[10,"from_binary_str",E,E,23,[[["str"]],["self"]]],[10,"from_dec_str",E,E,23,[[["str"],["u32"]],["self"]]],[10,"from_hex_str",E,E,23,[[["str"],["u32"]],["self"]]],[10,"as_binary_str",E,E,23,[[["self"]],[[R[5],[R[6]]],[R[6]]]]],[10,"as_u64",E,E,23,[[["self"]],[[R[5],["u64"]],["u64"]]]],[10,"as_bool",E,E,23,[[["self"]],[[R[5],["bool"]],["bool"]]]],[10,"get_a_solution",E,E,23,[[["self"]],[[R[8],[R[18]]],[R[18]]]]],[10,R[31],E,E,23,[[["self"]]]],[10,"get_id",E,E,23,[[["self"]],["i32"]]],[10,"get_width",E,E,23,[[["self"]],["u32"]]],[10,"get_symbol",E,E,23,[[["self"]],[["str"],[R[5],["str"]]]]],[10,"set_symbol",E,E,23,[[["str"],["self"],[R[5],["str"]]]]],[10,"is_const",E,E,23,[[["self"]],["bool"]]],[10,"has_same_width",E,E,23,[[["self"]],["bool"]]],[10,"assert",E,E,23,[[["self"]],[R[8]]]],[10,"is_failed_assumption",E,E,23,[[["self"]],["bool"]]],[10,"_eq",E,E,23,[[["self"]],["self"]]],[10,"_ne",E,E,23,[[["self"]],["self"]]],[10,"add",E,E,23,[[["self"]],["self"]]],[10,"sub",E,E,23,[[["self"]],["self"]]],[10,"mul",E,E,23,[[["self"]],["self"]]],[10,"udiv",E,E,23,[[["self"]],["self"]]],[10,"sdiv",E,E,23,[[["self"]],["self"]]],[10,"urem",E,E,23,[[["self"]],["self"]]],[10,"srem",E,E,23,[[["self"]],["self"]]],[10,"smod",E,E,23,[[["self"]],["self"]]],[10,"inc",E,E,23,[[["self"]],["self"]]],[10,"dec",E,E,23,[[["self"]],["self"]]],[10,"neg",E,E,23,[[["self"]],["self"]]],[10,"uaddo",E,E,23,[[["self"]],["self"]]],[10,"saddo",E,E,23,[[["self"]],["self"]]],[10,"usubo",E,E,23,[[["self"]],["self"]]],[10,"ssubo",E,E,23,[[["self"]],["self"]]],[10,"umulo",E,E,23,[[["self"]],["self"]]],[10,"smulo",E,E,23,[[["self"]],["self"]]],[10,"sdivo",E,E,23,[[["self"]],["self"]]],[10,"not",E,E,23,[[["self"]],["self"]]],[10,"and",E,E,23,[[["self"]],["self"]]],[10,"or",E,E,23,[[["self"]],["self"]]],[10,"xor",E,E,23,[[["self"]],["self"]]],[10,"nand",E,E,23,[[["self"]],["self"]]],[10,"nor",E,E,23,[[["self"]],["self"]]],[10,"xnor",E,E,23,[[["self"]],["self"]]],[10,"sll",E,E,23,[[["self"]],["self"]]],[10,"srl",E,E,23,[[["self"]],["self"]]],[10,"sra",E,E,23,[[["self"]],["self"]]],[10,"rol",E,E,23,[[["self"]],["self"]]],[10,"ror",E,E,23,[[["self"]],["self"]]],[10,"redand",E,E,23,[[["self"]],["self"]]],[10,"redor",E,E,23,[[["self"]],["self"]]],[10,"redxor",E,E,23,[[["self"]],["self"]]],[10,"ugt",E,E,23,[[["self"]],["self"]]],[10,"ugte",E,E,23,[[["self"]],["self"]]],[10,"sgt",E,E,23,[[["self"]],["self"]]],[10,"sgte",E,E,23,[[["self"]],["self"]]],[10,"ult",E,E,23,[[["self"]],["self"]]],[10,"ulte",E,E,23,[[["self"]],["self"]]],[10,"slt",E,E,23,[[["self"]],["self"]]],[10,"slte",E,E,23,[[["self"]],["self"]]],[10,"zext",E,E,23,[[["u32"],["self"]],["self"]]],[10,"sext",E,E,23,[[["u32"],["self"]],["self"]]],[10,"slice",E,E,23,[[["u32"],["self"]],["self"]]],[10,"concat",E,E,23,[[["self"]],["self"]]],[10,"repeat",E,E,23,[[["u32"],["self"]],["self"]]],[10,"iff",E,E,23,[[["self"]],["self"]]],[10,"implies",E,E,23,[[["self"]],["self"]]],[10,"cond_bv",E,E,23,[[["self"]],["self"]]],[11,"zero_extend_to_bits",E,"Zero-extend a `BV` to the specified number of bits. The…",23,[[["u32"],["self"]],["self"]]],[11,"sign_extend_to_bits",E,"Sign-extend a `BV` to the specified number of bits. The…",23,[[["u32"],["self"]],["self"]]],[11,"uadds",E,"Saturating addition, unsigned. The result will be the same…",23,[[["self"]],["self"]]],[11,"sadds",E,"Saturating addition, signed. The result will be the same…",23,[[["self"]],["self"]]],[11,"usubs",E,"Saturating subtraction, unsigned. The result will be the…",23,[[["self"]],["self"]]],[11,"ssubs",E,"Saturating subtraction, signed. The result will be the…",23,[[["self"]],["self"]]],[8,R[93],E,"Trait for things which can act like 'memories', that is,…",N,N],[16,R[51],E,E,24,N],[16,"Index",E,E,24,N],[16,"Value",E,E,24,N],[10,R[29],E,R[23],24,[[["str"],[R[5],["str"]],["bool"]],["self"]]],[10,R[30],E,R[23],24,[[["str"],[R[5],["str"]],["bool"]],["self"]]],[10,"read",E,R[35],24,[[["u32"],["self"]],[R[8]]]],[10,"write",E,R[36],24,[[["self"]],[R[8]]]],[10,R[31],E,"Get a reference to the solver instance this `Memory`…",24,[[["self"]]]],[10,R[33],E,"Adapt the `Memory` to a new solver instance.",24,[[["self"]]]],[6,"Result",R[14],"A type alias for convenience, similar to how…",N,N],[11,"unwrap_to_i8",E,E,7,[[],["i8"]]],[11,"unwrap_to_i16",E,E,7,[[],["i16"]]],[11,"unwrap_to_i32",E,E,7,[[],["i32"]]],[11,"unwrap_to_i64",E,E,7,[[],["i64"]]],[11,"unwrap_to_ptr",E,E,7,[[],["u64"]]],[11,"into",E,E,8,[[],[U]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[52],E,E,8,[[[U]],[R[8]]]],[11,R[53],E,E,8,[[],[R[8]]]],[11,R[58],E,E,8,[[["self"]],[T]]],[11,R[54],E,E,8,[[["self"]],[T]]],[11,R[57],E,E,8,[[["self"]],[R[59]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[55],E,E,0,[[["self"]],[T]]],[11,R[56],E,E,0,[[["self"],[T]]]],[11,R[52],E,E,0,[[[U]],[R[8]]]],[11,R[53],E,E,0,[[],[R[8]]]],[11,R[58],E,E,0,[[["self"]],[T]]],[11,R[54],E,E,0,[[["self"]],[T]]],[11,R[57],E,E,0,[[["self"]],[R[59]]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[55],E,E,1,[[["self"]],[T]]],[11,R[56],E,E,1,[[["self"],[T]]]],[11,R[52],E,E,1,[[[U]],[R[8]]]],[11,R[53],E,E,1,[[],[R[8]]]],[11,R[58],E,E,1,[[["self"]],[T]]],[11,R[54],E,E,1,[[["self"]],[T]]],[11,R[57],E,E,1,[[["self"]],[R[59]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[55],E,E,2,[[["self"]],[T]]],[11,R[56],E,E,2,[[["self"],[T]]]],[11,R[52],E,E,2,[[[U]],[R[8]]]],[11,R[53],E,E,2,[[],[R[8]]]],[11,R[58],E,E,2,[[["self"]],[T]]],[11,R[54],E,E,2,[[["self"]],[T]]],[11,R[57],E,E,2,[[["self"]],[R[59]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[55],E,E,3,[[["self"]],[T]]],[11,R[56],E,E,3,[[["self"],[T]]]],[11,R[52],E,E,3,[[[U]],[R[8]]]],[11,R[53],E,E,3,[[],[R[8]]]],[11,R[58],E,E,3,[[["self"]],[T]]],[11,R[54],E,E,3,[[["self"]],[T]]],[11,R[57],E,E,3,[[["self"]],[R[59]]]],[11,"into",E,E,9,[[],[U]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into_iter",E,E,9,[[],["i"]]],[11,R[52],E,E,9,[[[U]],[R[8]]]],[11,R[53],E,E,9,[[],[R[8]]]],[11,R[58],E,E,9,[[["self"]],[T]]],[11,R[54],E,E,9,[[["self"]],[T]]],[11,R[57],E,E,9,[[["self"]],[R[59]]]],[11,"reduce",E,E,9,[[["f"]],[R[5]]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[55],E,E,4,[[["self"]],[T]]],[11,R[56],E,E,4,[[["self"],[T]]]],[11,R[60],E,E,4,[[["self"]],[R[6]]]],[11,R[52],E,E,4,[[[U]],[R[8]]]],[11,R[53],E,E,4,[[],[R[8]]]],[11,R[58],E,E,4,[[["self"]],[T]]],[11,R[54],E,E,4,[[["self"]],[T]]],[11,R[57],E,E,4,[[["self"]],[R[59]]]],[11,"into",E,E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[55],E,E,5,[[["self"]],[T]]],[11,R[56],E,E,5,[[["self"],[T]]]],[11,R[52],E,E,5,[[[U]],[R[8]]]],[11,R[53],E,E,5,[[],[R[8]]]],[11,R[58],E,E,5,[[["self"]],[T]]],[11,R[54],E,E,5,[[["self"]],[T]]],[11,R[57],E,E,5,[[["self"]],[R[59]]]],[11,"into",E,E,6,[[],[U]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[55],E,E,6,[[["self"]],[T]]],[11,R[56],E,E,6,[[["self"],[T]]]],[11,R[60],E,E,6,[[["self"]],[R[6]]]],[11,R[52],E,E,6,[[[U]],[R[8]]]],[11,R[53],E,E,6,[[],[R[8]]]],[11,R[58],E,E,6,[[["self"]],[T]]],[11,R[54],E,E,6,[[["self"]],[T]]],[11,R[57],E,E,6,[[["self"]],[R[59]]]],[11,"into",E,E,7,[[],[U]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[55],E,E,7,[[["self"]],[T]]],[11,R[56],E,E,7,[[["self"],[T]]]],[11,R[52],E,E,7,[[[U]],[R[8]]]],[11,R[53],E,E,7,[[],[R[8]]]],[11,R[58],E,E,7,[[["self"]],[T]]],[11,R[54],E,E,7,[[["self"]],[T]]],[11,R[57],E,E,7,[[["self"]],[R[59]]]],[11,"into",R[61],E,10,[[],[U]]],[11,"from",E,E,10,[[[T]],[T]]],[11,R[55],E,E,10,[[["self"]],[T]]],[11,R[56],E,E,10,[[["self"],[T]]]],[11,R[52],E,E,10,[[[U]],[R[8]]]],[11,R[53],E,E,10,[[],[R[8]]]],[11,R[58],E,E,10,[[["self"]],[T]]],[11,R[54],E,E,10,[[["self"]],[T]]],[11,R[57],E,E,10,[[["self"]],[R[59]]]],[11,"into",E,E,11,[[],[U]]],[11,"from",E,E,11,[[[T]],[T]]],[11,R[55],E,E,11,[[["self"]],[T]]],[11,R[56],E,E,11,[[["self"],[T]]]],[11,R[52],E,E,11,[[[U]],[R[8]]]],[11,R[53],E,E,11,[[],[R[8]]]],[11,R[58],E,E,11,[[["self"]],[T]]],[11,R[54],E,E,11,[[["self"]],[T]]],[11,R[57],E,E,11,[[["self"]],[R[59]]]],[11,"into",E,E,12,[[],[U]]],[11,"from",E,E,12,[[[T]],[T]]],[11,R[55],E,E,12,[[["self"]],[T]]],[11,R[56],E,E,12,[[["self"],[T]]]],[11,R[52],E,E,12,[[[U]],[R[8]]]],[11,R[53],E,E,12,[[],[R[8]]]],[11,R[58],E,E,12,[[["self"]],[T]]],[11,R[54],E,E,12,[[["self"]],[T]]],[11,R[57],E,E,12,[[["self"]],[R[59]]]],[11,"into",R[62],E,14,[[],[U]]],[11,"from",E,E,14,[[[T]],[T]]],[11,R[55],E,E,14,[[["self"]],[T]]],[11,R[56],E,E,14,[[["self"],[T]]]],[11,R[52],E,E,14,[[[U]],[R[8]]]],[11,R[53],E,E,14,[[],[R[8]]]],[11,R[58],E,E,14,[[["self"]],[T]]],[11,R[54],E,E,14,[[["self"]],[T]]],[11,R[57],E,E,14,[[["self"]],[R[59]]]],[11,"into",R[63],E,15,[[],[U]]],[11,"from",E,E,15,[[[T]],[T]]],[11,R[55],E,E,15,[[["self"]],[T]]],[11,R[56],E,E,15,[[["self"],[T]]]],[11,R[52],E,E,15,[[[U]],[R[8]]]],[11,R[53],E,E,15,[[],[R[8]]]],[11,R[58],E,E,15,[[["self"]],[T]]],[11,R[54],E,E,15,[[["self"]],[T]]],[11,R[57],E,E,15,[[["self"]],[R[59]]]],[11,"into",R[64],E,16,[[],[U]]],[11,"from",E,E,16,[[[T]],[T]]],[11,R[55],E,E,16,[[["self"]],[T]]],[11,R[56],E,E,16,[[["self"],[T]]]],[11,R[52],E,E,16,[[[U]],[R[8]]]],[11,R[53],E,E,16,[[],[R[8]]]],[11,R[58],E,E,16,[[["self"]],[T]]],[11,R[54],E,E,16,[[["self"]],[T]]],[11,R[57],E,E,16,[[["self"]],[R[59]]]],[11,"into",R[65],E,17,[[],[U]]],[11,"from",E,E,17,[[[T]],[T]]],[11,R[55],E,E,17,[[["self"]],[T]]],[11,R[56],E,E,17,[[["self"],[T]]]],[11,R[60],E,E,17,[[["self"]],[R[6]]]],[11,R[52],E,E,17,[[[U]],[R[8]]]],[11,R[53],E,E,17,[[],[R[8]]]],[11,R[58],E,E,17,[[["self"]],[T]]],[11,R[54],E,E,17,[[["self"]],[T]]],[11,R[57],E,E,17,[[["self"]],[R[59]]]],[11,"into",E,E,18,[[],[U]]],[11,"from",E,E,18,[[[T]],[T]]],[11,R[55],E,E,18,[[["self"]],[T]]],[11,R[56],E,E,18,[[["self"],[T]]]],[11,R[52],E,E,18,[[[U]],[R[8]]]],[11,R[53],E,E,18,[[],[R[8]]]],[11,R[58],E,E,18,[[["self"]],[T]]],[11,R[54],E,E,18,[[["self"]],[T]]],[11,R[57],E,E,18,[[["self"]],[R[59]]]],[11,"into",R[66],E,19,[[],[U]]],[11,"from",E,E,19,[[[T]],[T]]],[11,R[55],E,E,19,[[["self"]],[T]]],[11,R[56],E,E,19,[[["self"],[T]]]],[11,R[52],E,E,19,[[[U]],[R[8]]]],[11,R[53],E,E,19,[[],[R[8]]]],[11,R[58],E,E,19,[[["self"]],[T]]],[11,R[54],E,E,19,[[["self"]],[T]]],[11,R[57],E,E,19,[[["self"]],[R[59]]]],[11,"into",E,E,20,[[],[U]]],[11,"from",E,E,20,[[[T]],[T]]],[11,R[55],E,E,20,[[["self"]],[T]]],[11,R[56],E,E,20,[[["self"],[T]]]],[11,R[52],E,E,20,[[[U]],[R[8]]]],[11,R[53],E,E,20,[[],[R[8]]]],[11,R[58],E,E,20,[[["self"]],[T]]],[11,R[54],E,E,20,[[["self"]],[T]]],[11,R[57],E,E,20,[[["self"]],[R[59]]]],[11,"into",R[67],E,25,[[],[U]]],[11,"from",E,E,25,[[[T]],[T]]],[11,R[55],E,E,25,[[["self"]],[T]]],[11,R[56],E,E,25,[[["self"],[T]]]],[11,R[52],E,E,25,[[[U]],[R[8]]]],[11,R[53],E,E,25,[[],[R[8]]]],[11,R[58],E,E,25,[[["self"]],[T]]],[11,R[54],E,E,25,[[["self"]],[T]]],[11,R[57],E,E,25,[[["self"]],[R[59]]]],[11,"into",E,E,26,[[],[U]]],[11,"from",E,E,26,[[[T]],[T]]],[11,R[55],E,E,26,[[["self"]],[T]]],[11,R[56],E,E,26,[[["self"],[T]]]],[11,R[52],E,E,26,[[[U]],[R[8]]]],[11,R[53],E,E,26,[[],[R[8]]]],[11,R[58],E,E,26,[[["self"]],[T]]],[11,R[54],E,E,26,[[["self"]],[T]]],[11,R[57],E,E,26,[[["self"]],[R[59]]]],[11,R[29],R[63],E,15,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,R[30],E,E,15,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,"read",E,E,15,[[["u32"],["self"]],[R[8]]]],[11,"write",E,E,15,[[["self"]],[R[8]]]],[11,R[31],E,E,15,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[33],E,E,15,[[["self"],["btor"],["rc",["btor"]]]]],[11,R[29],R[64],E,16,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,R[30],E,E,16,[[["str"],["rc",["btor"]],[R[5],["str"]],["btor"],["bool"]],["self"]]],[11,"read",E,E,16,[[["u32"],["self"]],[R[8]]]],[11,"write",E,E,16,[[["self"]],[R[8]]]],[11,R[31],E,E,16,[[["self"]],[["btor"],["rc",["btor"]]]]],[11,R[33],E,E,16,[[["self"],["btor"],["rc",["btor"]]]]],[11,"from",R[14],E,2,[[[R[68]]],[R[71]]]],[11,"next",E,E,9,[[["self"]],[R[5]]]],[11,"clone",R[61],E,10,[[["self"]],[R[1]]]],[11,"clone",E,E,12,[[["self"]],[R[69]]]],[11,"clone",E,E,11,[[["self"]],[R[70]]]],[11,"clone",R[62],E,14,[[["self"]],["functionhooks"]]],[11,"clone",R[14],E,0,[[["self"]],["state"]]],[11,"clone",E,E,2,[[["self"]],[R[71]]]],[11,"clone",E,E,4,[[["self"]],[R[75]]]],[11,"clone",E,E,3,[[["self"]],[R[77]]]],[11,"clone",E,E,1,[[["self"]],[R[68]]]],[11,"clone",R[63],E,15,[[["self"]],[R[78]]]],[11,"clone",R[64],E,16,[[["self"]],[R[78]]]],[11,"clone",R[65],E,17,[[["self"]],[R[38]]]],[11,"clone",E,E,18,[[["self"]],[R[72]]]],[11,"clone",R[66],E,19,[[["self"]],[R[19]]]],[11,"clone",E,E,20,[[["self"]],[R[73]]]],[11,"clone",R[14],E,5,[[["self"]],[R[7]]]],[11,"clone",E,E,6,[[["self"]],["error"]]],[11,"clone",R[67],E,25,[[["self"]],[R[3]]]],[11,"clone",E,E,26,[[["self"]],[R[79]]]],[11,"clone",R[14],E,7,[[["self"]],[R[80]]]],[11,R[74],R[61],"Default values for all configuration parameters.",10,[[],["self"]]],[11,R[74],R[62],"Provides predefined hooks for common functions. (At the…",14,[[],["self"]]],[11,R[74],R[65],E,18,[[],[R[72]]]],[11,"cmp",R[14],E,2,[[["self"],[R[71]]],[R[76]]]],[11,"cmp",E,E,4,[[[R[75]],["self"]],[R[76]]]],[11,"eq",R[61],E,12,[[[R[69]],["self"]],["bool"]]],[11,"ne",E,E,12,[[[R[69]],["self"]],["bool"]]],[11,"eq",E,E,11,[[[R[70]],["self"]],["bool"]]],[11,"eq",R[14],E,2,[[["self"],[R[71]]],["bool"]]],[11,"ne",E,E,2,[[["self"],[R[71]]],["bool"]]],[11,"eq",E,E,4,[[[R[75]],["self"]],["bool"]]],[11,"ne",E,E,4,[[[R[75]],["self"]],["bool"]]],[11,"eq",E,E,3,[[[R[77]],["self"]],["bool"]]],[11,"ne",E,E,3,[[[R[77]],["self"]],["bool"]]],[11,"eq",E,E,1,[[["self"]],["bool"]]],[11,"eq",R[63],E,15,[[["self"]],["bool"]]],[11,"eq",R[64],E,16,[[[R[78]],["self"]],["bool"]]],[11,"ne",E,E,16,[[[R[78]],["self"]],["bool"]]],[11,"eq",R[65],E,17,[[["self"],[R[38]]],["bool"]]],[11,"ne",E,E,17,[[["self"],[R[38]]],["bool"]]],[11,"eq",R[66],E,19,[[["self"],[R[19]]],["bool"]]],[11,"ne",E,E,19,[[["self"],[R[19]]],["bool"]]],[11,"eq",E,E,20,[[["self"],[R[73]]],["bool"]]],[11,"ne",E,E,20,[[["self"],[R[73]]],["bool"]]],[11,"eq",R[14],E,5,[[["self"],[R[7]]],["bool"]]],[11,"ne",E,E,5,[[["self"],[R[7]]],["bool"]]],[11,"eq",E,E,6,[[["self"],["error"]],["bool"]]],[11,"ne",E,E,6,[[["self"],["error"]],["bool"]]],[11,"eq",R[67],E,25,[[["self"],[R[3]]],["bool"]]],[11,"eq",E,E,26,[[["self"],[R[79]]],["bool"]]],[11,"eq",R[14],E,7,[[[R[80]],["self"]],["bool"]]],[11,"ne",E,E,7,[[[R[80]],["self"]],["bool"]]],[11,R[81],E,E,2,[[["self"],[R[71]]],[[R[76]],[R[5],[R[76]]]]]],[11,"lt",E,E,2,[[["self"],[R[71]]],["bool"]]],[11,"le",E,E,2,[[["self"],[R[71]]],["bool"]]],[11,"gt",E,E,2,[[["self"],[R[71]]],["bool"]]],[11,"ge",E,E,2,[[["self"],[R[71]]],["bool"]]],[11,R[81],E,E,4,[[[R[75]],["self"]],[[R[76]],[R[5],[R[76]]]]]],[11,"lt",E,E,4,[[[R[75]],["self"]],["bool"]]],[11,"le",E,E,4,[[[R[75]],["self"]],["bool"]]],[11,"gt",E,E,4,[[[R[75]],["self"]],["bool"]]],[11,"ge",E,E,4,[[[R[75]],["self"]],["bool"]]],[11,"fmt",E,E,4,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[65],E,17,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[14],E,6,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[61],E,12,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",E,E,11,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[14],E,4,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",E,E,2,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",E,E,3,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",E,E,1,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[63],E,15,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[64],E,16,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[65],E,17,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[66],E,19,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",E,E,20,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[14],E,5,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",E,E,6,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[67],E,25,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",E,E,26,[[["self"],[R[82]]],[R[8]]]],[11,"fmt",R[14],E,7,[[["self"],[R[82]]],[R[8]]]],[11,"hash",E,E,2,[[["self"],["__h"]]]],[11,"hash",E,E,4,[[["self"],["__h"]]]],[11,"hash",R[65],E,17,[[["self"],["__h"]]]],[11,"hash",R[14],E,5,[[["self"],["__h"]]]],[11,"from_iter",R[65],E,18,[[["intoiterator"]],["self"]]]],"p":[[3,"State"],[3,R[83]],[3,R[84]],[3,R[85]],[4,R[86]],[4,R[87]],[4,"Error"],[4,R[88]],[3,"Project"],[3,R[89]],[3,"Config"],[4,R[90]],[4,R[91]],[8,"IsCall"],[3,R[92]],[3,R[93]],[3,R[93]],[3,R[94]],[3,R[95]],[4,R[96]],[4,R[97]],[8,"Backend"],[8,R[51]],[8,"BV"],[8,R[93]],[3,R[98]],[3,R[99]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);