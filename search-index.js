var N=null,E="",T="t",U="u",searchIndex={};
var R=["bbname","config","backend","project","btorbackend","option","returnvalue","string","result","Construct a new `Project` from a path to a directory…","Get the offset (in bytes) of the element at the given…","function_hooks","Removes the function hook for the given function, which…","haybale","operand","Returns `true` if under the current constraints, `a` and…","bvsolution","possiblesolutions","callsite","A new `Memory`, whose contents at all addresses are…","INDEX_BITS","CELL_BITS","BITS_IN_BYTE","LOG_BITS_IN_BYTE","CELL_BYTES","new_uninitialized","new_zero_initialized","get_solver","Get a reference to the `Btor` instance this `Memory`…","change_solver","Adapt the `Memory` to a new `Btor` instance.","Read any number (>0) of bits of memory, at any alignment.…","Write any number (>0) of bits of memory, at any alignment.","Add a memory watchpoint. It will be enabled unless/until…","watchpoint","Remove the memory watchpoint with the given `name`.","Enable the memory watchpoint(s) with the given name.","Returns `true` if current constraints are satisfiable,…","sat_with_extra_constraints","bvs_must_be_equal","bvs_can_be_equal","get_possible_solutions_for_bv","Get a description of the possible solutions for the `BV`.","max_possible_solution_for_bv","Get the maximum possible solution for the `BV`: that is,…","min_possible_solution_for_bv","Get the minimum possible solution for the `BV`: that is,…","SolverRef","try_from","try_into","borrow_mut","to_owned","clone_into","type_id","borrow","typeid","haybale::function_hooks","haybale::memory","haybale::simple_memory","to_string","haybale::watchpoints","haybale::solver_utils","haybale::backend","concretize","location","watchpoints","solutioncount","solutionvalue","pathentry","ordering","memory","simplememorybackend","formatter","Location","PathEntry","Concretize","ReturnValue","SolutionValue","ExecutionManager","FunctionHooks","Memory","Watchpoint","Watchpoints","PossibleSolutions","SolutionCount","BtorBackend","SimpleMemoryBackend"];

searchIndex["haybale"]={"doc":"For an introduction to the crate and how to get started,…","i":[[3,"Project",R[13],"A `Project` is a collection of LLVM code to be explored,…",N,N],[3,"State",E,"A `State` describes the full program state at a given…",N,N],[12,"solver",E,"Reference to the solver instance being used",0,N],[12,R[1],E,"The configuration being used",0,N],[12,"cur_loc",E,"Indicates the instruction which is currently being executed",0,N],[3,R[73],E,"Fully describes a code location within the LLVM IR.",N,N],[12,"module",E,E,1,N],[12,"func",E,E,1,N],[12,R[0],E,E,1,N],[12,"instr",E,"Index of the instruction within the basic block. E.g., 0…",1,N],[3,R[74],E,"Describes one segment of a path through the LLVM IR.",N,N],[12,"modname",E,E,2,N],[12,"funcname",E,E,2,N],[12,R[0],E,E,2,N],[12,"instr",E,"Index of the instruction within the basic block at which…",2,N],[3,R[78],E,"An `ExecutionManager` allows you to symbolically explore…",N,N],[3,"Config",E,"Various settings which affect how the symbolic execution…",N,N],[12,"loop_bound",E,"Maximum number of times to execute any given line of LLVM…",3,N],[12,"null_detection",E,"If `true`, all memory accesses will be checked to ensure…",3,N],[12,"concretize_memcpy_lengths",E,"When encountering a `memcpy`, `memset`, or `memmove` with…",3,N],[12,R[11],E,"The set of currently active function hooks; see…",3,N],[12,"initial_mem_watchpoints",E,"The initial memory watchpoints when a `State` is created…",3,N],[4,R[75],E,E,N,N],[13,"Symbolic",E,"Handle everything fully symbolically - that is, have the…",4,N],[13,"Arbitrary",E,"Pick one possible value arbitrarily. Often this may choose…",4,N],[13,"Prefer",E,"Prefer the given `u64` value if it is a possible value.…",4,N],[13,"Maximum",E,"Choose the maximum possible value. `Maximum` will be…",4,N],[13,"Minimum",E,"Choose the minimum possible value. `Minimum` will be…",4,N],[4,R[76],E,"A simple enum describing the value returned from a function",N,N],[13,"Return",E,"The function or call returns this value",5,N],[13,"ReturnVoid",E,"The function or call returns void",5,N],[13,"Throw",E,"The function or call throws this value (using the LLVM…",5,N],[13,"Abort",E,"The function or call aborts without ever returning (e.g.,…",5,N],[4,"Error",E,"Error types used throughout this crate",N,N],[13,"Unsat",E,"While performing an operation, we discovered the current…",6,N],[13,"LoopBoundExceeded",E,"The current path has exceeded the configured `loop_bound`…",6,N],[13,"NullPointerDereference",E,"The current path has attempted to dereference a null…",6,N],[13,"FunctionNotFound",E,"Processing a call of a function with the given name, but…",6,N],[13,"BoolCoercionError",E,"An operation attempted to coerce a `BV` more than one bit…",6,N],[13,"SolverError",E,"The solver returned this processing error while evaluating…",6,N],[13,"UnsupportedInstruction",E,"Encountered an LLVM instruction which is not currently…",6,N],[13,"MalformedInstruction",E,"Encountered an LLVM instruction which was malformed, or at…",6,N],[13,"OtherError",E,"Some kind of error which doesn't fall into one of the…",6,N],[4,R[77],E,"A simple enum describing either an integer value or a…",N,N],[13,"I8",E,E,7,N],[13,"I16",E,E,7,N],[13,"I32",E,E,7,N],[13,"I64",E,E,7,N],[13,"Ptr",E,E,7,N],[5,"pretty_bb_name",E,"Format a basic block `Name` into a concise representation…",N,[[["name"]],[R[7]]]],[5,"symex_function",E,"Begin symbolic execution of the function named `funcname`,…",N,[[[R[2]],[R[3]],["str"],[R[1]]],[[R[2]],["executionmanager"]]]],[5,"find_zero_of_func",E,"Given a function, find values of its inputs such that it…",N,[[[R[1],[R[4]]],[R[3]],[R[4]],["str"]],[["vec",[R[67]]],[R[5],["vec"]]]]],[5,"get_possible_return_values_of_func",E,"Get a description of the possible return values of a…",N,[[[R[1],[R[4]]],["u32"],[R[3]],["usize"],[R[5],["u32"]],[R[4]],["str"]],[[R[17],[R[6]]],[R[6],["u64"]]]]],[11,"from_bc_path",E,"Construct a new `Project` from a path to an LLVM bitcode…",8,[[],[[R[7]],[R[8],[R[7]]]]]],[11,"from_bc_paths",E,"Construct a new `Project` from multiple LLVM bitcode files",8,[[],[[R[7]],[R[8],[R[7]]]]]],[11,"from_bc_dir",E,R[9],8,[[["str"]],[[R[8],["error"]],["error"]]]],[11,"from_bc_dir_with_blacklist",E,R[9],8,[[["str"]],[[R[8],["error"]],["error"]]]],[11,"add_bc_path",E,"Add the code in the given LLVM bitcode file to the `Project`",8,[[["self"]],[[R[7]],[R[8],[R[7]]]]]],[11,"add_bc_dir",E,"Add the code in the given directory to the `Project`. See…",8,[[["self"],["str"]],[["error"],[R[8],["error"]]]]],[11,"add_bc_dir_with_blacklist",E,"Add the code in the given directory, except for…",8,[[["self"],["str"]],[["error"],[R[8],["error"]]]]],[11,"all_functions",E,"Iterate over all `Function`s in the `Project`. Gives pairs…",8,[[["self"]]]],[11,"all_global_vars",E,"Iterate over all `GlobalVariable`s in the `Project`. Gives…",8,[[["self"]]]],[11,"all_global_aliases",E,"Iterate over all `GlobalAlias`es in the `Project`. Gives…",8,[[["self"]]]],[11,"all_named_struct_types",E,"Iterate over all named struct types in the `Project`.…",8,[[["self"]]]],[11,"active_module_names",E,"Get the names of the LLVM modules which have been parsed…",8,[[["self"]]]],[11,"get_func_by_name",E,"Search the project for a function with the given name. If…",8,[[["str"],["self"]],[R[5]]]],[11,"get_named_struct_type_by_name",E,"Search the project for a named struct type with the given…",8,[[["str"],["self"]],[R[5]]]],[11,"get_inner_struct_type_from_named",E,"Given a `NamedStructType`, get the `StructType`…",8,[[["self"],["type"]],[["arc",["rwlock"]],[R[5],["arc"]]]]],[11,"state",E,"Provides access to the `State` resulting from the end of…",9,[[["self"]],["state"]]],[11,"mut_state",E,"Provides mutable access to the underlying `State` (see…",9,[[["self"]],["state"]]],[11,"param_bvs",E,"Provides access to the `BV` objects representing each of…",9,[[["self"]],["vec"]]],[0,"layout",E,"Functions related to the in-memory layout of data types.",N,N],[5,"size","haybale::layout","Get the size of the `Type`, in bits",N,[[["type"]],["usize"]]],[5,"fp_size",E,"Get the size of the `FPType`, in bits",N,[[["fptype"]],["usize"]]],[5,"get_offset_constant_index",E,R[10],N,[[["usize"],["type"]],[R[8]]]],[5,"get_offset_bv_index",E,R[10],N,[[["type"],["v"]],[R[8]]]],[17,"POINTER_SIZE_BITS",E,"our convention is that pointers are 64 bits",N,N],[11,"new",R[13],"Creates a new `Config` with the given `loop_bound` and…",3,[[[R[63]],["usize"],["bool"]],["self"]]],[0,R[11],E,"Functions and structures for defining and activating…",N,N],[3,R[79],R[56],"A set of function hooks, which will be executed instead of…",N,N],[5,"generic_stub_hook",E,"This hook ignores the function arguments and returns an…",N,[[[R[3]],["state"],["iscall"]],[[R[8],[R[6]]],[R[6]]]]],[5,"abort_hook",E,"This hook ignores the function arguments and returns…",N,[[[R[3]],["state"],["iscall"]],[[R[8],[R[6]]],[R[6]]]]],[6,"Argument",E,"An `Argument` represents a single argument to a called…",N,N],[8,"IsCall",E,"`IsCall` exists to unify the commonalities between LLVM…",N,N],[10,"get_called_func",E,E,10,[[["self"]],["either"]]],[10,"get_arguments",E,E,10,[[["self"]],["vec"]]],[10,"get_return_attrs",E,E,10,[[["self"]],["vec"]]],[10,"get_fn_attrs",E,E,10,[[["self"]],["vec"]]],[10,"get_calling_convention",E,E,10,[[["self"]],["callingconvention"]]],[11,"new",E,"Create a blank `FunctionHooks` instance with no function…",11,[[],["self"]]],[11,"add",E,"Adds a function hook. The `hook` will be executed instead…",11,[[["self"],["h"]]]],[11,"add_cpp_demangled",E,"Exactly like `add()`, but takes the (C++) demangled name…",11,[[["self"],["h"]]]],[11,"add_rust_demangled",E,"Exactly like `add()`, but takes the (Rust) demangled name…",11,[[["self"],["h"]]]],[11,"remove",E,R[12],11,[[["self"],["str"]]]],[11,"remove_cpp_demangled",E,R[12],11,[[["self"],["str"]]]],[11,"remove_rust_demangled",E,R[12],11,[[["self"],["str"]]]],[11,"is_hooked",E,"Determine whether there is an active hook for the given…",11,[[["self"],["str"]],["bool"]]],[0,"alloc_utils",R[13],"Utility functions for performing memory allocation. These…",N,N],[5,"malloc","haybale::alloc_utils","Allocate a number of bytes given by the `Operand`.",N,[[["state"],[R[14]]],[R[8]]]],[5,"zalloc",E,"Allocate a number of bytes given by the `Operand`. The…",N,[[["state"],[R[14]]],[R[8]]]],[5,"calloc",E,"Allocate a number of bytes given by `a` times `b`, where…",N,[[["state"],[R[14]]],[R[8]]]],[5,"realloc",E,"Reallocate the given `addr` to be at least the number of…",N,[[["state"],[R[14]]],[R[8]]]],[11,"new",R[13],"`start_loc`: the `Location` where the `State` should begin…",0,[[[R[1]],[R[64]],[R[3]]],["self"]]],[11,"fork",E,"Fully duplicate the `State`. Unlike with `clone()`, the…",0,[[["self"]],["self"]]],[11,"sat",E,R[37],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[38],E,"Returns `true` if the current constraints plus the given…",0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[39],E,R[15],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,R[40],E,R[15],0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,"get_a_solution_for_bv",E,"Get one possible concrete value for the `BV`. Returns…",0,[[["self"]],[[R[8],[R[5]]],[R[5],[R[16]]]]]],[11,"get_a_solution_for_irname",E,"Get one possible concrete value for the given IR `Name`…",0,[[["self"],[R[7]],["name"]],[[R[8],[R[5]]],[R[5],[R[16]]]]]],[11,R[41],E,R[42],0,[[["self"],["usize"]],[[R[8],[R[17]]],[R[17],[R[16]]]]]],[11,"get_possible_solutions_for_irname",E,"Get a description of the possible solutions for the given…",0,[[["self"],["usize"],["name"],[R[7]]],[[R[8],[R[17]]],[R[17],[R[16]]]]]],[11,R[43],E,R[44],0,[[["self"]],[[R[5],["u64"]],[R[8],[R[5]]]]]],[11,"max_possible_solution_for_irname",E,"Get the maximum possible solution for the given IR `Name`…",0,[[["self"],[R[7]],["name"]],[[R[5],["u64"]],[R[8],[R[5]]]]]],[11,R[45],E,R[46],0,[[["self"]],[[R[5],["u64"]],[R[8],[R[5]]]]]],[11,"min_possible_solution_for_irname",E,"Get the minimum possible solution for the given IR `Name`…",0,[[["self"],[R[7]],["name"]],[[R[5],["u64"]],[R[8],[R[5]]]]]],[11,"bv_from_bool",E,"Create a `BV` constant representing the given `bool`…",0,[[["self"],["bool"]]]],[11,"bv_from_i32",E,"Create a `BV` representing the given constant `i32` value,…",0,[[["self"],["u32"],["i32"]]]],[11,"bv_from_u32",E,"Create a `BV` representing the given constant `u32` value,…",0,[[["self"],["u32"]]]],[11,"bv_from_i64",E,"Create a `BV` representing the given constant `i64` value,…",0,[[["self"],["i64"],["u32"]]]],[11,"bv_from_u64",E,"Create a `BV` representing the given constant `u64` value,…",0,[[["self"],["u32"],["u64"]]]],[11,"zero",E,"Create a `BV` representing the constant `0` of the given…",0,[[["self"],["u32"]]]],[11,"one",E,"Create a `BV` representing the constant `1` of the given…",0,[[["self"],["u32"]]]],[11,"ones",E,"Create a `BV` constant of the given width, where all bits…",0,[[["self"],["u32"]]]],[11,"new_bv_with_name",E,"Create a new (unconstrained) `BV` for the given `Name` (in…",0,[[["self"],["name"],["u32"]],[R[8]]]],[11,"assign_bv_to_name",E,"Assign the given `BV` to the given `Name` (in the current…",0,[[["self"],["name"]],[R[8]]]],[11,"record_bv_result",E,"Record the result of `thing` to be `resultval`. Assumes…",0,[[["self"]],[R[8]]]],[11,"overwrite_latest_version_of_bv",E,"Overwrite the latest version of the given `Name` to…",0,[[["self"],["name"]]]],[11,"operand_to_bv",E,"Convert an `Operand` to the appropriate `BV`. Assumes the…",0,[[["self"],[R[14]]],[R[8]]]],[11,"const_to_bv",E,"Convert a `Constant` to the appropriate `BV`.",0,[[["self"],["constant"]],[R[8]]]],[11,"get_pointer_to_function",E,"Get a pointer to the given function name. The name will be…",0,[[["self"]],[R[5]]]],[11,"get_pointer_to_function_hook",E,"Get a pointer to the currently active hook for the given…",0,[[["self"],["str"]],[R[5]]]],[11,"read",E,"Read a value `bits` bits long from memory at `addr`. Note…",0,[[["self"],["u32"]],[R[8]]]],[11,"write",E,"Write a value into memory at `addr`. Note that `val` can…",0,[[["self"]],[R[8]]]],[11,"add_mem_watchpoint",E,R[33],0,[[["self"],[R[34]]],["bool"]]],[11,"rm_mem_watchpoint",E,R[35],0,[[["self"],["str"]],["bool"]]],[11,"disable_watchpoint",E,"Disable the memory watchpoint with the given `name`.…",0,[[["self"],["str"]],["bool"]]],[11,"enable_watchpoint",E,R[36],0,[[["self"],["str"]],["bool"]]],[11,"allocate",E,"Allocate a value of size `bits`; return a pointer to the…",0,[[["self"]]]],[11,"get_allocation_size",E,"Get the size, in bits, of the allocation at the given…",0,[[["self"]],[[R[5],["u64"]],[R[8],[R[5]]]]]],[11,"record_path_entry",E,"Record the current location as a `PathEntry` in the…",0,[[["self"]]]],[11,"get_path",E,"Get the `PathEntry`s that have been recorded, in order",0,[[["self"]],["vec"]]],[11,"push_callsite",E,"Record entering a normal `Call` at the current location",0,[[["self"],["call"]]]],[11,"push_invokesite",E,"Record entering the given `Invoke` at the current location",0,[[["self"],["invoke"]]]],[11,"pop_callsite",E,"Record leaving the current function. Returns the…",0,[[["self"]],[[R[5],[R[18]]],[R[18]]]]],[11,"save_backtracking_point",E,"Save the current state, about to enter the `BasicBlock`…",0,[[["self"],["name"]]]],[11,"revert_to_backtracking_point",E,"returns `Ok(true)` if the operation was successful,…",0,[[["self"]],[[R[8],["bool"]],["bool"]]]],[11,"count_backtracking_points",E,"returns the number of saved backtracking points",0,[[["self"]],["usize"]]],[11,"pretty_llvm_backtrace",E,"returns a `String` containing a formatted view of the…",0,[[["self"]],[R[7]]]],[11,"current_assignments_as_pretty_string",E,"returns a `String` describing a set of satisfying…",0,[[["self"]],[[R[7]],[R[8],[R[7]]]]]],[0,R[70],E,"Implementation of a `Memory` based on a Boolector array…",N,N],[3,R[80],R[57],E,N,N],[18,R[20],E,E,12,N],[18,R[21],E,E,12,N],[18,R[22],E,E,12,N],[18,R[23],E,E,12,N],[18,R[24],E,E,12,N],[18,"LOG_CELL_BYTES",E,E,12,N],[18,"CELL_OFFSET_MASK",E,E,12,N],[11,R[25],E,R[19],12,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,R[26],E,R[19],12,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,R[27],E,R[28],12,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[29],E,R[30],12,[[["self"],["rc",["btor"]],["btor"]]]],[11,"read",E,R[31],12,[[["self"],["bv"],["u32"]],[["bv",["rc"]],[R[8],["bv"]]]]],[11,"write",E,R[32],12,[[["self"],["bv",["rc"]],["bv"],["rc",["btor"]]],[R[8]]]],[0,"simple_memory",R[13],"Simple implementation of a `Memory` based on a Boolector…",N,N],[3,R[80],R[58],E,N,N],[18,R[20],E,E,13,N],[18,R[21],E,E,13,N],[18,R[22],E,E,13,N],[18,R[23],E,E,13,N],[18,R[24],E,E,13,N],[11,R[25],E,R[19],13,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,R[26],E,R[19],13,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,R[27],E,R[28],13,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[29],E,R[30],13,[[["self"],["rc",["btor"]],["btor"]]]],[11,"read",E,R[31],13,[[["self"],["bv"],["u32"]],[["bv",["rc"]],[R[8],["bv"]]]]],[11,"write",E,R[32],13,[[["self"],["bv",["rc"]],["bv"],["rc",["btor"]]],[R[8]]]],[0,R[65],R[13],"Structures for defining and processing memory watchpoints",N,N],[3,R[81],R[60],"A `Watchpoint` describes a segment of memory to watch.",N,N],[3,R[82],E,"Stores information about watchpoints and performs…",N,N],[11,"new",E,"A memory watchpoint for the `bytes` bytes of memory at the…",14,[[["u64"]],["self"]]],[11,"new",E,"Construct a new `Watchpoints` instance with no watchpoints",15,[[],["self"]]],[11,"from_iter",E,"Construct a new `Watchpoints` instance from an iterator…",15,[[],["self"]]],[11,"add",E,R[33],15,[[["self"],[R[34]]],["bool"]]],[11,"remove",E,R[35],15,[[["self"],["str"]],["bool"]]],[11,"disable",E,"Disable the memory watchpoint with the given `name`.",15,[[["self"],["str"]],["bool"]]],[11,"enable",E,R[36],15,[[["self"],["str"]],["bool"]]],[0,"solver_utils",R[13],"Simple utilities for interacting with the solver",N,N],[4,R[83],R[61],E,N,N],[13,"Exactly",E,"This is exactly the set of possible solutions; there are…",16,N],[13,"AtLeast",E,"All of the solutions in this set are possible solutions,…",16,N],[4,R[84],E,E,N,N],[13,"Exactly",E,"There are exactly this many solutions",17,N],[13,"AtLeast",E,"There are at least this many solutions",17,N],[5,"sat",E,R[37],N,[[["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[38],E,"Returns `true` if the current constraints plus the…",N,[[["btor"]],[[R[8],["bool"]],["bool"]]]],[5,R[39],E,R[15],N,[[["btor"],["v"]],[[R[8],["bool"]],["bool"]]]],[5,R[40],E,R[15],N,[[["btor"],["v"]],[[R[8],["bool"]],["bool"]]]],[5,R[41],E,R[42],N,[[["usize"],["v"]],[[R[8],[R[17]]],[R[17],[R[16]]]]]],[5,R[43],E,R[44],N,[[["v"]],[[R[5],["u64"]],[R[8],[R[5]]]]]],[5,R[45],E,R[46],N,[[["v"]],[[R[5],["u64"]],[R[8],[R[5]]]]]],[11,"as_u64_solutions",E,"Convert a `PossibleSolutions` over `BVSolution` into a…",16,[[["self"]],[[R[5],[R[17]]],[R[17],["u64"]]]]],[11,"count",E,"Get a count of how many possible solutions there are.",16,[[["self"]],[R[66]]]],[0,R[2],R[13],"Traits which abstract over the backend (BV types, memory…",N,N],[3,R[85],R[62],E,N,N],[3,R[86],E,E,N,N],[8,"Backend",E,"A `Backend` is just a collection of types which together…",N,N],[16,R[47],E,E,18,N],[16,"BV",E,E,18,N],[16,R[80],E,E,18,N],[8,R[47],E,"Trait for something which acts as a reference to a…",N,N],[16,"BV",E,E,19,N],[16,"Array",E,E,19,N],[10,"new",E,"Create a new `Btor` instance, initialize it as necessary,…",19,[[],["self"]]],[10,"duplicate",E,"As opposed to `clone()` which merely clones the reference,…",19,[[["self"]],["self"]]],[10,"match_bv",E,"Given a `BV` originally created for any `SolverRef`, get…",19,[[["self"]],[R[5]]]],[10,"match_array",E,"Given an `Array` originally created for any `SolverRef`,…",19,[[["self"]],[R[5]]]],[8,"BV",E,"Trait for things which can act like bitvectors",N,N],[16,R[47],E,E,20,N],[10,"new",E,E,20,[[["u32"],[R[5],["str"]],["str"]],["self"]]],[10,"from_bool",E,E,20,[[["bool"]],["self"]]],[10,"from_i32",E,E,20,[[["u32"],["i32"]],["self"]]],[10,"from_u32",E,E,20,[[["u32"]],["self"]]],[10,"from_i64",E,E,20,[[["i64"],["u32"]],["self"]]],[10,"from_u64",E,E,20,[[["u32"],["u64"]],["self"]]],[10,"zero",E,E,20,[[["u32"]],["self"]]],[10,"one",E,E,20,[[["u32"]],["self"]]],[10,"ones",E,E,20,[[["u32"]],["self"]]],[10,"from_binary_str",E,E,20,[[["str"]],["self"]]],[10,"from_dec_str",E,E,20,[[["u32"],["str"]],["self"]]],[10,"from_hex_str",E,E,20,[[["u32"],["str"]],["self"]]],[10,"as_binary_str",E,E,20,[[["self"]],[[R[7]],[R[5],[R[7]]]]]],[10,"as_u64",E,E,20,[[["self"]],[[R[5],["u64"]],["u64"]]]],[10,"as_bool",E,E,20,[[["self"]],[["bool"],[R[5],["bool"]]]]],[10,"get_a_solution",E,E,20,[[["self"]],[[R[8],[R[16]]],[R[16]]]]],[10,"get_id",E,E,20,[[["self"]],["i32"]]],[10,"get_width",E,E,20,[[["self"]],["u32"]]],[10,"get_symbol",E,E,20,[[["self"]],[[R[5],["str"]],["str"]]]],[10,"set_symbol",E,E,20,[[["self"],[R[5],["str"]],["str"]]]],[10,"is_const",E,E,20,[[["self"]],["bool"]]],[10,"has_same_width",E,E,20,[[["self"]],["bool"]]],[10,"assert",E,E,20,[[["self"]],[R[8]]]],[10,"is_failed_assumption",E,E,20,[[["self"]],["bool"]]],[10,"_eq",E,E,20,[[["self"]],["self"]]],[10,"_ne",E,E,20,[[["self"]],["self"]]],[10,"add",E,E,20,[[["self"]],["self"]]],[10,"sub",E,E,20,[[["self"]],["self"]]],[10,"mul",E,E,20,[[["self"]],["self"]]],[10,"udiv",E,E,20,[[["self"]],["self"]]],[10,"sdiv",E,E,20,[[["self"]],["self"]]],[10,"urem",E,E,20,[[["self"]],["self"]]],[10,"srem",E,E,20,[[["self"]],["self"]]],[10,"smod",E,E,20,[[["self"]],["self"]]],[10,"inc",E,E,20,[[["self"]],["self"]]],[10,"dec",E,E,20,[[["self"]],["self"]]],[10,"neg",E,E,20,[[["self"]],["self"]]],[10,"uaddo",E,E,20,[[["self"]],["self"]]],[10,"saddo",E,E,20,[[["self"]],["self"]]],[10,"usubo",E,E,20,[[["self"]],["self"]]],[10,"ssubo",E,E,20,[[["self"]],["self"]]],[10,"umulo",E,E,20,[[["self"]],["self"]]],[10,"smulo",E,E,20,[[["self"]],["self"]]],[10,"sdivo",E,E,20,[[["self"]],["self"]]],[10,"not",E,E,20,[[["self"]],["self"]]],[10,"and",E,E,20,[[["self"]],["self"]]],[10,"or",E,E,20,[[["self"]],["self"]]],[10,"xor",E,E,20,[[["self"]],["self"]]],[10,"nand",E,E,20,[[["self"]],["self"]]],[10,"nor",E,E,20,[[["self"]],["self"]]],[10,"xnor",E,E,20,[[["self"]],["self"]]],[10,"sll",E,E,20,[[["self"]],["self"]]],[10,"srl",E,E,20,[[["self"]],["self"]]],[10,"sra",E,E,20,[[["self"]],["self"]]],[10,"rol",E,E,20,[[["self"]],["self"]]],[10,"ror",E,E,20,[[["self"]],["self"]]],[10,"redand",E,E,20,[[["self"]],["self"]]],[10,"redor",E,E,20,[[["self"]],["self"]]],[10,"redxor",E,E,20,[[["self"]],["self"]]],[10,"ugt",E,E,20,[[["self"]],["self"]]],[10,"ugte",E,E,20,[[["self"]],["self"]]],[10,"sgt",E,E,20,[[["self"]],["self"]]],[10,"sgte",E,E,20,[[["self"]],["self"]]],[10,"ult",E,E,20,[[["self"]],["self"]]],[10,"ulte",E,E,20,[[["self"]],["self"]]],[10,"slt",E,E,20,[[["self"]],["self"]]],[10,"slte",E,E,20,[[["self"]],["self"]]],[10,"zext",E,E,20,[[["self"],["u32"]],["self"]]],[10,"sext",E,E,20,[[["self"],["u32"]],["self"]]],[10,"slice",E,E,20,[[["self"],["u32"]],["self"]]],[10,"concat",E,E,20,[[["self"]],["self"]]],[10,"repeat",E,E,20,[[["self"],["u32"]],["self"]]],[10,"iff",E,E,20,[[["self"]],["self"]]],[10,"implies",E,E,20,[[["self"]],["self"]]],[10,"cond_bv",E,E,20,[[["self"]],["self"]]],[8,R[80],E,"Trait for things which can act like 'memories', that is,…",N,N],[16,R[47],E,E,21,N],[16,"Index",E,E,21,N],[16,"Value",E,E,21,N],[10,R[25],E,R[19],21,[[["str"],[R[5],["str"]],["bool"]],["self"]]],[10,R[26],E,R[19],21,[[["str"],[R[5],["str"]],["bool"]],["self"]]],[10,"read",E,R[31],21,[[["self"],["u32"]],[R[8]]]],[10,"write",E,R[32],21,[[["self"]],[R[8]]]],[10,R[27],E,"Get a reference to the solver instance this `Memory`…",21,[[["self"]]]],[10,R[29],E,"Adapt the `Memory` to a new solver instance.",21,[[["self"]]]],[6,"Result",R[13],"A type alias for convenience, similar to how…",N,N],[11,"unwrap_to_i8",E,E,7,[[],["i8"]]],[11,"unwrap_to_i16",E,E,7,[[],["i16"]]],[11,"unwrap_to_i32",E,E,7,[[],["i32"]]],[11,"unwrap_to_i64",E,E,7,[[],["i64"]]],[11,"unwrap_to_ptr",E,E,7,[[],["u64"]]],[11,"into",E,E,8,[[],[U]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[48],E,E,8,[[[U]],[R[8]]]],[11,R[49],E,E,8,[[],[R[8]]]],[11,R[50],E,E,8,[[["self"]],[T]]],[11,R[54],E,E,8,[[["self"]],[T]]],[11,R[53],E,E,8,[[["self"]],[R[55]]]],[11,"into",E,E,0,[[],[U]]],[11,R[51],E,E,0,[[["self"]],[T]]],[11,R[52],E,E,0,[[["self"],[T]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[48],E,E,0,[[[U]],[R[8]]]],[11,R[49],E,E,0,[[],[R[8]]]],[11,R[50],E,E,0,[[["self"]],[T]]],[11,R[54],E,E,0,[[["self"]],[T]]],[11,R[53],E,E,0,[[["self"]],[R[55]]]],[11,"into",E,E,1,[[],[U]]],[11,R[51],E,E,1,[[["self"]],[T]]],[11,R[52],E,E,1,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[48],E,E,1,[[[U]],[R[8]]]],[11,R[49],E,E,1,[[],[R[8]]]],[11,R[50],E,E,1,[[["self"]],[T]]],[11,R[54],E,E,1,[[["self"]],[T]]],[11,R[53],E,E,1,[[["self"]],[R[55]]]],[11,"into",E,E,2,[[],[U]]],[11,R[51],E,E,2,[[["self"]],[T]]],[11,R[52],E,E,2,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[48],E,E,2,[[[U]],[R[8]]]],[11,R[49],E,E,2,[[],[R[8]]]],[11,R[50],E,E,2,[[["self"]],[T]]],[11,R[54],E,E,2,[[["self"]],[T]]],[11,R[53],E,E,2,[[["self"]],[R[55]]]],[11,"into",E,E,9,[[],[U]]],[11,"into_iter",E,E,9,[[],["i"]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[48],E,E,9,[[[U]],[R[8]]]],[11,R[49],E,E,9,[[],[R[8]]]],[11,R[50],E,E,9,[[["self"]],[T]]],[11,R[54],E,E,9,[[["self"]],[T]]],[11,R[53],E,E,9,[[["self"]],[R[55]]]],[11,"reduce",E,E,9,[[["f"]],[R[5]]]],[11,"into",E,E,3,[[],[U]]],[11,R[51],E,E,3,[[["self"]],[T]]],[11,R[52],E,E,3,[[["self"],[T]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[48],E,E,3,[[[U]],[R[8]]]],[11,R[49],E,E,3,[[],[R[8]]]],[11,R[50],E,E,3,[[["self"]],[T]]],[11,R[54],E,E,3,[[["self"]],[T]]],[11,R[53],E,E,3,[[["self"]],[R[55]]]],[11,"into",E,E,4,[[],[U]]],[11,R[51],E,E,4,[[["self"]],[T]]],[11,R[52],E,E,4,[[["self"],[T]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[48],E,E,4,[[[U]],[R[8]]]],[11,R[49],E,E,4,[[],[R[8]]]],[11,R[50],E,E,4,[[["self"]],[T]]],[11,R[54],E,E,4,[[["self"]],[T]]],[11,R[53],E,E,4,[[["self"]],[R[55]]]],[11,"into",E,E,5,[[],[U]]],[11,R[51],E,E,5,[[["self"]],[T]]],[11,R[52],E,E,5,[[["self"],[T]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[48],E,E,5,[[[U]],[R[8]]]],[11,R[49],E,E,5,[[],[R[8]]]],[11,R[50],E,E,5,[[["self"]],[T]]],[11,R[54],E,E,5,[[["self"]],[T]]],[11,R[53],E,E,5,[[["self"]],[R[55]]]],[11,R[59],E,E,6,[[["self"]],[R[7]]]],[11,"into",E,E,6,[[],[U]]],[11,R[51],E,E,6,[[["self"]],[T]]],[11,R[52],E,E,6,[[["self"],[T]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[48],E,E,6,[[[U]],[R[8]]]],[11,R[49],E,E,6,[[],[R[8]]]],[11,R[50],E,E,6,[[["self"]],[T]]],[11,R[54],E,E,6,[[["self"]],[T]]],[11,R[53],E,E,6,[[["self"]],[R[55]]]],[11,"into",E,E,7,[[],[U]]],[11,R[51],E,E,7,[[["self"]],[T]]],[11,R[52],E,E,7,[[["self"],[T]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[48],E,E,7,[[[U]],[R[8]]]],[11,R[49],E,E,7,[[],[R[8]]]],[11,R[50],E,E,7,[[["self"]],[T]]],[11,R[54],E,E,7,[[["self"]],[T]]],[11,R[53],E,E,7,[[["self"]],[R[55]]]],[11,"into",R[56],E,11,[[],[U]]],[11,R[51],E,E,11,[[["self"]],[T]]],[11,R[52],E,E,11,[[["self"],[T]]]],[11,"from",E,E,11,[[[T]],[T]]],[11,R[48],E,E,11,[[[U]],[R[8]]]],[11,R[49],E,E,11,[[],[R[8]]]],[11,R[50],E,E,11,[[["self"]],[T]]],[11,R[54],E,E,11,[[["self"]],[T]]],[11,R[53],E,E,11,[[["self"]],[R[55]]]],[11,"into",R[57],E,12,[[],[U]]],[11,R[51],E,E,12,[[["self"]],[T]]],[11,R[52],E,E,12,[[["self"],[T]]]],[11,"from",E,E,12,[[[T]],[T]]],[11,R[48],E,E,12,[[[U]],[R[8]]]],[11,R[49],E,E,12,[[],[R[8]]]],[11,R[50],E,E,12,[[["self"]],[T]]],[11,R[54],E,E,12,[[["self"]],[T]]],[11,R[53],E,E,12,[[["self"]],[R[55]]]],[11,"into",R[58],E,13,[[],[U]]],[11,R[51],E,E,13,[[["self"]],[T]]],[11,R[52],E,E,13,[[["self"],[T]]]],[11,"from",E,E,13,[[[T]],[T]]],[11,R[48],E,E,13,[[[U]],[R[8]]]],[11,R[49],E,E,13,[[],[R[8]]]],[11,R[50],E,E,13,[[["self"]],[T]]],[11,R[54],E,E,13,[[["self"]],[T]]],[11,R[53],E,E,13,[[["self"]],[R[55]]]],[11,R[59],R[60],E,14,[[["self"]],[R[7]]]],[11,"into",E,E,14,[[],[U]]],[11,R[51],E,E,14,[[["self"]],[T]]],[11,R[52],E,E,14,[[["self"],[T]]]],[11,"from",E,E,14,[[[T]],[T]]],[11,R[48],E,E,14,[[[U]],[R[8]]]],[11,R[49],E,E,14,[[],[R[8]]]],[11,R[50],E,E,14,[[["self"]],[T]]],[11,R[54],E,E,14,[[["self"]],[T]]],[11,R[53],E,E,14,[[["self"]],[R[55]]]],[11,"into",E,E,15,[[],[U]]],[11,R[51],E,E,15,[[["self"]],[T]]],[11,R[52],E,E,15,[[["self"],[T]]]],[11,"from",E,E,15,[[[T]],[T]]],[11,R[48],E,E,15,[[[U]],[R[8]]]],[11,R[49],E,E,15,[[],[R[8]]]],[11,R[50],E,E,15,[[["self"]],[T]]],[11,R[54],E,E,15,[[["self"]],[T]]],[11,R[53],E,E,15,[[["self"]],[R[55]]]],[11,"into",R[61],E,16,[[],[U]]],[11,R[51],E,E,16,[[["self"]],[T]]],[11,R[52],E,E,16,[[["self"],[T]]]],[11,"from",E,E,16,[[[T]],[T]]],[11,R[48],E,E,16,[[[U]],[R[8]]]],[11,R[49],E,E,16,[[],[R[8]]]],[11,R[50],E,E,16,[[["self"]],[T]]],[11,R[54],E,E,16,[[["self"]],[T]]],[11,R[53],E,E,16,[[["self"]],[R[55]]]],[11,"into",E,E,17,[[],[U]]],[11,R[51],E,E,17,[[["self"]],[T]]],[11,R[52],E,E,17,[[["self"],[T]]]],[11,"from",E,E,17,[[[T]],[T]]],[11,R[48],E,E,17,[[[U]],[R[8]]]],[11,R[49],E,E,17,[[],[R[8]]]],[11,R[50],E,E,17,[[["self"]],[T]]],[11,R[54],E,E,17,[[["self"]],[T]]],[11,R[53],E,E,17,[[["self"]],[R[55]]]],[11,"into",R[62],E,22,[[],[U]]],[11,R[51],E,E,22,[[["self"]],[T]]],[11,R[52],E,E,22,[[["self"],[T]]]],[11,"from",E,E,22,[[[T]],[T]]],[11,R[48],E,E,22,[[[U]],[R[8]]]],[11,R[49],E,E,22,[[],[R[8]]]],[11,R[50],E,E,22,[[["self"]],[T]]],[11,R[54],E,E,22,[[["self"]],[T]]],[11,R[53],E,E,22,[[["self"]],[R[55]]]],[11,"into",E,E,23,[[],[U]]],[11,R[51],E,E,23,[[["self"]],[T]]],[11,R[52],E,E,23,[[["self"],[T]]]],[11,"from",E,E,23,[[[T]],[T]]],[11,R[48],E,E,23,[[[U]],[R[8]]]],[11,R[49],E,E,23,[[],[R[8]]]],[11,R[50],E,E,23,[[["self"]],[T]]],[11,R[54],E,E,23,[[["self"]],[T]]],[11,R[53],E,E,23,[[["self"]],[R[55]]]],[11,R[25],R[57],E,12,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,R[26],E,E,12,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,"read",E,E,12,[[["self"],["u32"]],[R[8]]]],[11,"write",E,E,12,[[["self"]],[R[8]]]],[11,R[27],E,E,12,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[29],E,E,12,[[["self"],["rc",["btor"]],["btor"]]]],[11,R[25],R[58],E,13,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,R[26],E,E,13,[[["str"],["rc",["btor"]],["btor"],[R[5],["str"]],["bool"]],["self"]]],[11,"read",E,E,13,[[["self"],["u32"]],[R[8]]]],[11,"write",E,E,13,[[["self"]],[R[8]]]],[11,R[27],E,E,13,[[["self"]],[["rc",["btor"]],["btor"]]]],[11,R[29],E,E,13,[[["self"],["rc",["btor"]],["btor"]]]],[11,"default",R[13],"Default values for all configuration parameters.",3,[[],["self"]]],[11,"default",R[56],"Provides predefined hooks for common functions. (At the…",11,[[],["self"]]],[11,"clone",R[13],E,3,[[["self"]],[R[1]]]],[11,"clone",E,E,4,[[["self"]],[R[63]]]],[11,"clone",R[56],E,11,[[["self"]],["functionhooks"]]],[11,"clone",R[13],E,0,[[["self"]],["state"]]],[11,"clone",E,E,2,[[["self"]],[R[68]]]],[11,"clone",E,E,1,[[["self"]],[R[64]]]],[11,"clone",R[57],E,12,[[["self"]],[R[70]]]],[11,"clone",R[58],E,13,[[["self"]],[R[70]]]],[11,"clone",R[60],E,14,[[["self"]],[R[34]]]],[11,"clone",E,E,15,[[["self"]],[R[65]]]],[11,"clone",R[61],E,16,[[["self"]],[R[17]]]],[11,"clone",E,E,17,[[["self"]],[R[66]]]],[11,"clone",R[13],E,5,[[["self"]],[R[6]]]],[11,"clone",E,E,6,[[["self"]],["error"]]],[11,"clone",R[62],E,22,[[["self"]],[R[4]]]],[11,"clone",E,E,23,[[["self"]],[R[71]]]],[11,"clone",R[13],E,7,[[["self"]],[R[67]]]],[11,"partial_cmp",E,E,2,[[["self"],[R[68]]],[[R[5],[R[69]]],[R[69]]]]],[11,"lt",E,E,2,[[["self"],[R[68]]],["bool"]]],[11,"le",E,E,2,[[["self"],[R[68]]],["bool"]]],[11,"gt",E,E,2,[[["self"],[R[68]]],["bool"]]],[11,"ge",E,E,2,[[["self"],[R[68]]],["bool"]]],[11,"eq",E,E,4,[[["self"],[R[63]]],["bool"]]],[11,"ne",E,E,4,[[["self"],[R[63]]],["bool"]]],[11,"eq",E,E,2,[[["self"],[R[68]]],["bool"]]],[11,"ne",E,E,2,[[["self"],[R[68]]],["bool"]]],[11,"eq",E,E,1,[[["self"]],["bool"]]],[11,"eq",R[57],E,12,[[["self"]],["bool"]]],[11,"eq",R[58],E,13,[[["self"],[R[70]]],["bool"]]],[11,"ne",E,E,13,[[["self"],[R[70]]],["bool"]]],[11,"eq",R[60],E,14,[[["self"],[R[34]]],["bool"]]],[11,"ne",E,E,14,[[["self"],[R[34]]],["bool"]]],[11,"eq",R[61],E,16,[[["self"],[R[17]]],["bool"]]],[11,"ne",E,E,16,[[["self"],[R[17]]],["bool"]]],[11,"eq",E,E,17,[[["self"],[R[66]]],["bool"]]],[11,"ne",E,E,17,[[["self"],[R[66]]],["bool"]]],[11,"eq",R[13],E,5,[[["self"],[R[6]]],["bool"]]],[11,"ne",E,E,5,[[["self"],[R[6]]],["bool"]]],[11,"eq",E,E,6,[[["self"],["error"]],["bool"]]],[11,"ne",E,E,6,[[["self"],["error"]],["bool"]]],[11,"eq",R[62],E,22,[[["self"],[R[4]]],["bool"]]],[11,"eq",E,E,23,[[["self"],[R[71]]],["bool"]]],[11,"eq",R[13],E,7,[[["self"],[R[67]]],["bool"]]],[11,"ne",E,E,7,[[["self"],[R[67]]],["bool"]]],[11,"cmp",E,E,2,[[["self"],[R[68]]],[R[69]]]],[11,"from",E,E,2,[[[R[64]]],[R[68]]]],[11,"next",E,E,9,[[["self"]],[R[5]]]],[11,"hash",E,E,2,[[["self"],["__h"]]]],[11,"hash",R[60],E,14,[[["self"],["__h"]]]],[11,"hash",R[13],E,5,[[["self"],["__h"]]]],[11,"fmt",R[60],E,14,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[13],E,6,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",E,E,4,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",E,E,2,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",E,E,1,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[57],E,12,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[58],E,13,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[60],E,14,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[61],E,16,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",E,E,17,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[13],E,5,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",E,E,6,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[62],E,22,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",E,E,23,[[["self"],[R[72]]],[R[8]]]],[11,"fmt",R[13],E,7,[[["self"],[R[72]]],[R[8]]]]],"p":[[3,"State"],[3,R[73]],[3,R[74]],[3,"Config"],[4,R[75]],[4,R[76]],[4,"Error"],[4,R[77]],[3,"Project"],[3,R[78]],[8,"IsCall"],[3,R[79]],[3,R[80]],[3,R[80]],[3,R[81]],[3,R[82]],[4,R[83]],[4,R[84]],[8,"Backend"],[8,R[47]],[8,"BV"],[8,R[80]],[3,R[85]],[3,R[86]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);